---
title: DB의 트랜잭션 (2) 트랜잭션의 격리성, LOCK
date: 2021-10-02 14:00:00 +0900
categories: [DataBase, sql]
tags: [sql,lock,mysql,database,transaction]
---

# 트랜잭션의 격리성(고립성)

## ACID 중 I인 고립성

DB의 경우 공유목적이 있기에, 여러 트랜잭션이 동시에 수행 될 수 있다. DB입장에서는
각각의 트랜잭션이 다른 트랜잭션의 방해를 받지 않고 독립적으로 작업을 수행해야 하는 것이다.
이렇게 여러 트랜잭션이 동시 수행될때 간섭이나 충돌이 일어나지 않도록 하는 것을 __고립성__ 이라고 이야기한다.

### 동시성 제어

임의의 시간 t에서 트랜잭션 A, B가 동시에 실행되고 있으며 테이블 T를 다루고 있다. 이때 같은 데이터를
동시에 읽고, 쓰는 작업을 진행할 경우 데이터의 일관성이 훼손될 수 있다. 이때 충돌하지 않도록 제어하는 작업이 필요하다 .
이를 '동시성 제어'라고 이야기한다.

### 동시성 제어에 대한 시나리오

같은 테이블을 만지는 두개의 트랜잭션(A,B)이 동시에 실행될때, 다음과 같은 시나리오들이 벌어진다.

1. 트랜잭션 A,B 모두 읽기만 진행할 때
2. 트랜잭션 A,B 모두 쓰기를 진행할 때
3. 트랜잭션 A는 읽기만 진행, B는 쓰기를 진행

1번과 같은 상황은 동시 진행에 아무런 문제가 존재하지 않는것을 쉽게 예측할 수 있다.
하지만 2와 3과 같은 상황은 여러 문제점을 파생시키며 특히 2의 사이드이펙트는 파괴적이다.
> 2 상황에서 발생하는 문제를 갱신손실 문제라고한다.

#### 갱신 손실문제

두개의 트랜잭션이 한개의 데이터를 동시에 갱신(Update)할 때 발생하는 것이다. 이는 DB에서 절대 금기시 되는 현상이다.

<br/>

트랜잭션 A는 100원 인출하는 작업, B는 100원 입금하는 작업(모두 UPDATE문)을 진행한다고 해보자.
> 초기 balance는 1000원에 해당한다.

트랜잭션을 시작할 때, DB에 저장된 값을 주기억 장치의 버퍼로 가져와야 하기에 다음과 같은 표가 작성이 된다.

|트랜잭션 A|트랜잭션 B|버퍼의 data 값|번호|
|------|------|------|----|
|A=get_balance(X); A-=100;||X=1000|1|
||B=get_balance(X); B+=100|X=1000|2|
|write(A->X)||X=900|3|
||write(B->X|X=1100|4|

최종 X의 값은 1000이 되어야 하지만, 일관성이 깨져있는 것을 볼 수 있다. 이 일관성이 깨지는 과정은 다음과 같다.

1. A가 먼저 값을 읽어오고, 이에 대해 갱신을 준비중이다.
2. B가 다시 X값을 읽어오고 A작업 중간에 끼어들어 작업을 진행한다.
3. 3에서 A가 기록한 데이터를 무시하고 4에서 X값을 갱신하게 된다.

결론적으로 B는 잘못된 데이터로 작업해 잘못된 결과를 낸것이다. 이러한 시나리오를 갱신 손실 문제라고한다.
> 실제로 일어난다면 파급력은 엄청날 것이다.

결국 이를 해결하기 위해서는 A->B or B->A 처럼 순차적으로 진행해야 된다. 그러나 이렇게 진행할 경우 
공유 및 빠른 응답처리를 이루어내지 못한다. 따라서 이를 해결하고 트랜잭션을 동시에 실행시킬 수 있는 방법이 있어야 한다.

# 락(LOCK)

앞서 살펴본 파괴적인 갱신 손실 문제를 해결하려면 다른 트랜잭션이 해당 데이터를 사용하는지 여부를 알아야 한다.
즉, 실제 데이터를 수정하고 있는 트랜잭션이 `나는 수정중인 상태에요`라는 사실을 알리면 된다. 이를 알리는 방법이
`락(Lock)` 이라는 잠금장치에 해당한다.

## 락의 개념

락은 `수정할 데이터 단위`로 채워지게 되며, 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때 까지 기다려야 한다.
앞선 시나리오에 락을 적용한다면 어떻게 바뀔까?

|트랜잭션 A|트랜잭션 B|버퍼의 data 값|번호|
|------|------|------|----|
|LOCK(X); A=get_balance(X); A-=100;||X=1000|1|
||LOCK(X); wait(t)|X=1000|2|
|write(A->X); UNLOCK(X);||X=900|3|
||B=get_balance(X); B+=100; write(B->X); UNLOCK(X);|X=1000|4|

1. 트랜잭션 A는 데이터 수정중이라는 사실을 락을 걸어 알리고 실제 연산을 진행한다.
2. B도 마찬가지로 X에 접근하지만, 락이 걸려있어 대기한다.
3. A의 업데이트가 진행도디면 락을 풀어준다.
4. B는 다시 버퍼로 마지막으로 수정된 X값 (900)을 가져와 업데이트를 진행한다.

## 락의 유형

이처럼 락을 걸어 다른 트랜잭션을 대기 상태로 만드는 일은 응답시간에 영향을 줄 것이다. 따라서 이를 최소화 하는 방법이 필요하다.
트랜잭션의 데이터는 읽기만 하는 데이터(1), 읽고 쓰는 데이터(2), 쓰기만 하는 데이터(3) 가 존재하는데 이중 (1)의 경우는 어느정도 허용을 해도 문제가 없다.
이점을 고려하여 락의 유형을 2가지로 나누게 된다.

- 데이터 읽기를 표시하는 락(LS - shared Lock) 
- 쓰기작업이 포함된 락(LX - exclusive Lock) 

### 락을 사용하는 기준

- 데이터에 락이 걸려있지 않다면 트랜잭션은 데이터에 락을 걸 수 있다.
  - 데이터 X를 읽기만 할 경우 LS(X)를 요청한다.
  - 읽거나 쓰기를 할 경우 LX(X)를 요청한다.
- 데이터에 LS(X)를 걸어두면
  - LS(X)의 요청은 허용한다.
  - LX(X)는 허용하지 않는다.
- 데이터에 LX(X)를 걸어두면
  - LS(X), LX(X) 모두 허용하지 않는다.
- 트랜잭션이 락을 허용받지 못하면 대기상태에 머문다.

말 그래도, 공유락은 상호 허용이 가능하지만, 배타 락은 모두 대기상태로 만든다.

### 2단계 락킹(Locking)

앞서 확인하였듯이, 락을 사용한다면 갱신손실 문제를 해결할 수 있다. 하지만 역시 빈틈은 존재한다.

```text
데이터에 락을 걸었다가 풀고, 다시 거는 중간 과정에
락의 해지상태가 생기게 되면 다른 트랜잭션에 중간 결과를 보일 수 있다.
```
> 이를 방지하기 위해 2단계 락킹 기법을 사용한다.

2단계 락킹은 트랜잭션이 락을 걸고 해제하는 시점을 2단계로 나누어 진행한다.

- 확장 단계: 락을 획득하는 단계, 이미 획득한 락은 해제하지 않는다.
- 수축 단계: 락을 해제하는 단계, 새로운 락을 획득하지 않는다.

이 역시 시나리오를 통해 살펴보자. 트랜잭션 T1는 A계좌에서 B로 100원을 송금하고 T2는 두 계좌의 잔고를
10%씩 증가시키는 작업이다. 2단계 락킹이 적용되지 않았을 때와 적용 되었을때의 차이를 살펴보자.
> 둘다 잔고가 1000원씩 있다고 하였을때, 락킹이 적용된다면 합은 2200원이 되어야 한다.

- __2단계 락킹을 사용하지 않았을때__

|트랜잭션 1|트랜잭션 2|버퍼의 data 값|번호|
|------|------|------|----|
|LX(A); <br/> t1=get(A); <br/> t1-=100; <br/> A=write(t1) <br/> Unlock(A)||A=900|1|
||LX(A); <br/> t2=get(A); t2*=1.1 <br/> Unlock(A); <br/> LX(B); <br/> t2=get(B); t2*=1.1; <br/> B=write(t2); <br/> Unlock(B) |A=990<br/>B=1100|2|
|LX(B); <br/> t1=get(B); t1+=100; <br/> B=write(t1); <br/> Unlock(B)||A=990<br/>B=1200|3|

원인은 T1이 쓰기 작업중인 중간 데이터를 가져와 T2가 작업을 하였기에 일관성이 깨지게 된 것이다. 
즉, T1이 A에 락을 걸고 작업을 하다가 중간에 락을 해제하여 T2가 A에 접근이 가능해졌기 때문이다. 이를 해결하기 위해서는 트랜잭션이 작업을 완료하기 전에는 락을
해제하지 않아야 한다.

<br/>
이제 2단계 락킹을 적용해 문제를 해결해보자.

- __2단계 락킹이 적용__

|트랜잭션 1|트랜잭션 2|버퍼의 data 값|번호|
|------|------|------|----|
|LX(A); <br/> t1=get(A); <br/> t1-=100; <br/> A=write(t1)||A=900|1|
||LX(A); wait(t)||2|
|LX(B); <br/> t1=get(B); t1+=100; <br/> B=write(t1); <br/> Unlock(A) Unlock(B)||A=900<br/>B=1100|3|
||LX(A); <br/> t2=get(A); t2*=1.1 <br/> LX(B); <br/> t2=get(B); t2*=1.1; <br/> B=write(t2); <br/> Unlock(A); Unlock(B); |A=990<br/>B=1210|4|


전과 비교해보면 `Unlock()` 이 진행되는 시점차이가 존재한다. 앞선 단계로 미루어보면 확장 단계에서는 락을 걸기만 하고, 수축 단계에서는 락을 해지하기만 한다.

### 데드락

이렇게 `공유자원에 대한 관리` 이슈에는 빠질 수 없는 pitfall이 존재한다. 데드락에 해당하는데 락킹을 적용한 상황에서도 데드락 현상이 발생할 수 있다.
T1은 id가 1과 2에 해당한 계좌의 잔고를 100원올리고 T2는 id가 2와 1에 대한 계좌에 10%를 이자로 준다고 해보자.

<br/>

1. T1의 경우 id가 1인 계좌에 락을 건다.
2. T2의 경우 id가 2인 계좌에 락을 건다.
3. T1이 id가 2인 계좌에 락을 요청하면 대기 상태가 된다.
4. 이 순간 T2도 id가 1인 계좌에 락을 요청하면 대기 상태가 된다.

__해결은 어떻게?__

<br/>

일반적으로 위와같은 데드락이 발생하면 T1 혹은 T2중 하나를 강제로 중지시킨다. 그리고 나머지 트랜잭션은 정상적으로 실행된다.
이 때 중지 시키는 트랜잭션에서 변경한 데이터는 다시 롤백시켜둔다.
> T2를 중지시킨다면 T1이 변경한 id 1의 잔고는 원래 상태로 바꾸어 두어야한다.

대기 그래프를 그려보는 것으로 데드락의 발생 여부를 예상해 볼 수 있다. 트랜잭션을 노드, 락 요청을 화살표로 표현했을 때 사이클이 존재한다면 이는 데드락이
발생한 것이다.


# 출처

- [MYSQL로 배우는 DB이론과 실습](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791156644576&orderClick=JAK)