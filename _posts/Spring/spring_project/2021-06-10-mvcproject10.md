---
title: 스프링 mvc 프로젝트 + AWS EC2에 빌드까지(10) CI,CD
date: 2021-06-09 11:00:00 +0900
categories: [Spring, spring_project]
tags: [spring,spring mvc,springboot,springframework,java]
---

# 이전 글

[이전글](https://vitriol95.github.io/posts/mvcproject9/) 에서는 직접 아마존 EC2에 빌드하는 시간을 가졌다. 이번 시간엔 Travis CI와 Nginx를 이용해 이의 CI / CD를 구축해보자.

---

# Travis CI

GitHub에서 제공하는 오픈소스 CI 툴에 해당한다. 깃허브에서 빌드할 프로젝트 Repository를 활성화 시킨 뒤, 루트 디렉토리안에(build.gradle과 같은 위치에) travis.yml파일을 생성하여 이에 대한 조건을 달아주어야 한다.

```yaml
# .travis.yml

language: java
jdk:
  - openjdk11

branches:
  only:
    - master

# Travis CI 서버의 홈
cache:
  directories:
    - '$HOME/.m2/repository'
    - '$HOME/.gradle'
script: "./gradlew clean build"


# CI 실행 완료시 메일로 알람
notifications:
  email:
    recipients:
      - vitriol95@snu.ac.kr
```
master 브랜치에 push되었을때만 아래의 명령을 실행하게 된다. CI의 속도를 올려주기 위해 캐싱을 진행할 것인데, 이를 Travis CI 서버의 홈 디렉토리에 캐시하여 같은 의존성은 다시 받지 않도록 한다.

<br>
이후 script: 를 통해 브랜치에 푸쉬되었을 때 수행할 명령어를 설정한다. QueryDsl로 생기는 Q파일이 clean후 정리되며 build후 다시 생겨나므로 위 명령을 달아두었다.
> 마지막으로 실행이 완료되었을 때 내용을 받을 메일을 설정해둔다.

---
## AWS S3 

만들어진 Jar 파일을 전달할 AWS S3 인스턴스를 만들어야 한다. CodeDeploy는 저장 기능이 없기에, Travis CI가 빌드한 결과물을 보관할 공간이 필요하다.

<br>
가장 먼저, S3에 Access 할 수 있는 IAM 계정을 정의하고, 정책을 연결해 둔 뒤 생성된 액세스 키 ID와 비밀 액세스 키를 Travis CI에 등록해 두면 된다.

<img src="/assets/img/mvcproject/45.JPG">

이후, .travis.yml 파일을 수정해 준다.

```yml
# Previous Code
before_deploy:
  - zip -r mvc-service *
  - mkdir -p deploy
  - mv mvc-service.zip deploy/mvc-service.zip

deploy:
  - provider: s3
    access_key_id: $AWS_ACCESS_KEY
    secret_access_key: $AWS_SECRET_KEY
    bucket: mvcservice-s3
    region: ap-northeast-2
    skip_cleanup: true
    acl: private
    local_dir: deploy
    wait-until-deployed: true
```
before_deploy와 deploy 명령이 추가되었다. Deploy가 되기 전 명령으로 before_deploy를 수행한다. 
<br>

1. 가장 먼저 만들어진 JAR파일을 mvc-service라는 이름으로 zip파일로 묶는다.
2. 이후 deploy라는 디렉토리를 현재 위치에 만들어준다.
3. 그리고 만들어진 zip파일을 이 deploy디렉토리 안으로 집어넣어 준다.
> 우리가 최종적으로 S3에게 던져줄 폴더이다.
4. 이후 deploy 명령을 정의해준다. 만들어준 S3 버킷에 대한 정보를 넣어주며, `local_dir`에 우리가 전달할 파일이 모여있는 deploy폴더를 넘겨준다.

---
## Code Deploy
EC2 인스턴스에 AWSCodeDeploy를 제어할 수 있는 IAM역할을 설정해 주고, 내부에 CodeDeploy요청을 받을 수 있는 에이전트 설치가 필요하다.
> AWS에서 CodeDeploy 배포그룹을 생성해야 하며, 그 안에는 현재 사용중인 EC2가 들어있어야 한다.

```
aws s3 cp s3://aws-codedeploy-ap-northeast-2/latest/install . --region ap-northeast-2

받아졌다면, install을 진행한다.
chmod +x ./install
sudo ./install auto
```

모두 완료가 되었다면 CodeDeploy에이전트가 정상실행상태인지 확인해 볼 수 있다.

```
sudo service codedeploy-agent status
```

<img src="/assets/img/mvcproject/45.JPG">
> 잘 작동중이다!

또한 S3로 부터 받을 Jar파일의 압축파일을 전달받을 새로운 경로를 생성해 주었다.
```
mkdir ~/app/ci && mkdir ~/app/ci/zip
```
Travis CI 빌드가 완료되면 S3에 zip파일이 보내지고, 이는 ~/app/ci/zip에 복사되어 압축을 풀예정이다.

<br>
이 설정을 직접 프로젝트에 남겨주어야 한다. AWS CodeDeploy에 대한 설정은 appspec.yml파일을 만들어 남겨야 한다.

```yaml
# appspec.yml
version: 0.0
os: linux
files:
  - source: /
    destination: /home/ec2-user/app/ci/zip
    overwrite: yes
```
CodeDeploy에서 전달해 준 파일중 destination에 이동시킬 대상을 지정해야 한다. 여기서는 루트경로('/')로 설정해 주어, S3로 부터 받은 모든 파일을 넘겨준다.

<br>
이후 .travis.yml에도 codedeploy 설정을 넣어준다. 

```yaml
# .travis.yml

deploy:
    # Previous Code
  - provider: codedeploy
    access_key_id: $AWS_ACCESS_KEY
    secret_access_key: $AWS_SECRET_KEY
    bucket: mvcservice-s3
    key: mvc-service.zip
    bundle_type: zip
    application: mvc-service
    deployment_group: mvc-service-group
    region: ap-northeast-2
    wait-until-deployed: true
```
빌드파일의 압축파일과, codedeploy의 어플리케이션 이름 및 그룹을 함께 전달한다.

<br>
준비가 거의 완료되었다. 이를 기반으로 실제 Jar를 다시 배포해보자. 이전까지는 EC2내부에 deploy.sh 파일을 실행시켰지만, 이를 어플리케이션 내부로 넣어보고자 한다. 따라서 프로젝트의 루트 디렉토리 안에 scripts라는 폴더를 생성하고 스크립트 파일을 만들어 보도록 하자.

```sh
# deploy.sh

#!/bin/bash

REPOSITORY=/home/ec2-user/app/ci
PROJECT_NAME=mvc-service

cp $REPOSITORY/zip/*.jar $REPOSITORY/
CURRENT_PID=$(pgrep -fl mvc-service | grep jar | awk '{print $1}')

echo "> pid: $CURRENT_PID"

if [-z "$CURRENT_PID"]; then
  echo "어플리케이션 바로 실행"
else
  echo "> kill -15 $CURRENT_PID"
  kill -15 $CURRENT_PID
  sleep 5
fi

JAR_NAME=$(ls -tr $REPOSITORY/*.jar | tail -n 1)
chmod +x $JAR_NAME
nohup java -jar -Dsping.config.location=classpath:/application.yml,/home/ec2-user/app/application-real-db.yml -Dspring.profiles.active=real-db $JAR_NAME > $REPOSITORY/nohup.out 2>&1 &
```
EC2 내부에 만들었던 deploy.sh파일과 굉장히 유사하다. 조금 다른 점이 있다면 이미 빌드를 마친 상태이므로 ./gradlew 명령어가 들어있지 않다. 그리고 nohup 명령어에 `$JAR_NAME > $REPOSITORY/nohup.out`이 추가되었다.

<br>
nohup을 실행하게 되면 codeDeploy는 무한정 대기하게 되는데, 이때 생기는 표준입출력이 모두 CodeDeploy로그에 찍히게 된다. 우리는 이를 Repository내의 nohup.out으로 IO Redirection을 해줌으로써 모든 로그를 nohup.out에서 확인한다.

<br>
그리고 이러한 스크립트 파일들을 S3 -> CodeDeploy를 통해 EC2로 옮겨갔을 때, 바로 실행시키게 끔 해야하므로 .travis.yml파일을 다음과 같이 수정해 준다.
before_deploy 명령을 통해 실행할 것이다.

```yaml
before_deploy:
  - mkdir -p before-deploy
  - cp scripts/*.sh before-deploy/
  - cp appspec.yml before-deploy/
  - cp build/libs/*.jar before-deploy/
  - cd before-deploy && zip -r before-deploy *
  - cd ../ && mkdir -p deploy
  - mv before-deploy/before-deploy.zip deploy/mvc-service.zip
```

이 리눅스 명령어 흐름은 다음과 같다.
1. before-deploy라는 디렉토리를 생성하고, 아까 프로젝트 루트폴더내에 작성한 sh파일이 모여있는 scripts 폴더를 복사한다.
2. codeDeploy 설정에 필요한 appspec.yml파일도 복사한다.
3. 이후 빌드가 완료된 jar파일도 복사해준다.
4. sh, appspec, jar파일이 모여있는 before-deploy 폴더를 zip하고 이를 deploy라는 파일에 mvc-service.zip이라는 이름으로 전달한다.

<br>
이렇게 codedeploy를 통해서 mvc-service.zip파일이 전달되며 deploy.sh파일에 의해 압축을 해제하게 된다. 그래서 우리가 추가적으로 해야할 일은 codeDeploy가 옮겨졌을 때, 이 deploy.sh를 실행시켜준다.

<br>
위의 명령과, 권한을 주기위해 appspec.yml에 다음과 같은 코드를 넣어준다.

```yaml
permissions:
  - object: /
    pattern: "**"
    owner: ec2-user
    group: ec2-user

hooks:
  ApplicationStart:
    - location: deploy.sh 
      timeout: 60
      runas: ec2-user
```
pemissions를 이용해 codedeploy에서 EC2로 넘겨준 파일을 ec2-user 권한을 갖도록 한다. 이후, application이 시작할 때 deploy.sh를 ec2-user권한으로 수행하도록 한다.
> timeout으로 60초이상 수행되지 않도록 시간 제한을 둔다.

<br>
이후, github에 push를 해보자.