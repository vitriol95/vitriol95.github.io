---
title: 도커의 레이어저장, 네트워크
date: 2021-10-03 12:00:00 +0900
categories: [DevOps,docker]
tags: [docker,layer,linux,network]
---

## DOCKER

### 도커의 레이어 저장방식

 도커 이미지는 컨테이너 실행을 위한 정보들을 가지고 있기에, 용량이 수백메가에 이른다. 만약 기존 이미지에 파일 하나를 추가했다고 이를 다시 다운로드 한다면, 매우 비 효율적이라 볼 수 있다.
<br>
 도커는 이런 문제를 해결하기 위해서 layer라는 개념을 사용하고, 유니온 파일 시스템(UFS)을 이용해 여러개의 레이어를 하나의 파일시스템으로 사용하게 해준다. 

<img src="/assets/img/docker/1.png">

[출처](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html)
<br/>
위 그림이 적절한 예시가 된다. webapp이미지를 nginx 이미지 기반으로 만들었다면 A+B+C+nginx+source 레이어로 구성된다. 이때 webapp의 소스를 수정하게 되면 A,B,C,nginx 레이어를 제외한 새로운 source 레이어만 다운받으면 되기 때문에 굉장히 효율적인 이미지 관리가 가능하다.

#### UFS?
UFS는 여러개의 파일 시스템을 하나의 파일 시스템에 마운트 하는 기능이다. 여러개의 파일 시스템을 하나로 합치다보면, 중복되는 파일이 존재하는데 UFS에서는 나중에 마운트된 파일로 overlay 하게된다.
> 도커 이미지에서 레이어는 개념적으로 각각의 파일 시스템을 겹쳐 놓은 형태라 할 수 있다.

#### 궁금증 1 - 이미지를 공유할 경우
하나의 이미지로 여러 컨테이너를 독립적으로 사용할 수 있다. 이때, 같은 이미지에서 생성된 컨테이너들이 동일한 파일 시스템을 공유하고 있다면, 어떻게 컨테이너가 독립적으로 실행 될 수 있을까.

#### 해답 1 - CoW 전략
UFS에서는 위와 같은 상황을 방지하기 위해 Copy on write라는 전략을 사용한다. 기존 레이어위에 새로운(상위) 레이어가 쌓일 경우, 하위 레이어는 읽기 전용(R/O)상태가 된다. 또한, 상위에서 하위에 쓰기 작업을 수행할 경우엔 하위 레이어를 복사하여 사용하기에, 아무런 영향을 주지 않고 진행할 수 있다.

<br/>
도커에서 레이어는 크게 컨테이너(상위)레이어와 이미지(하위)레이어로 구분이 된다. 컨테이너가 파일 시스템에 쓰기 작업을 수행할 경우, 실질적으로는 하위 레이어의 복사본에 해당 작업을 수행하기 때문에 서로 다른 컨테이너가 하위 레이어를 공유하고 있어도 서로 독립적인 파일 시스템 운용이 가능해진다.

<br/>
실제로 컨테이너를 생성할 때 기존 이미지 레이어 위에 읽기/쓰기 레이어를 추가하는 것을 확인할 수 있다.

<img src="/assets/img/docker/2.png">

이렇게 도커에서 관리되는 모든 레이어와 관련된 정보는 호스트 파일시스템 내의 /var/lib/docker폴더에 저장된다. 
> 이 영역을 Docker area 혹은 Backing Filesystem 이라고 부른다.

#### 해답 1 이어서 - Docker Storage Driver
컨테이너 레이어에서 실제로 데이터를 쓰는 작업을 수행한다. 작성된 파일은 컨테이너가 삭제 되면 함께 제거되며, 컨테이너 레이어에서는 파일을 읽고 쓰는 작업은 호스트 머신에서 작성하는 것 보다 느리다(만약 써야할 작업이 많다면 볼륨 마운트하여 사용하자).  
> 대표적으로 생각나는건 DB나.. 로그 파일.. 메시지큐 같은것이 있겠다.

<br/>
Docker storage Driver는 인터페이스로, 여러 구현 방식들이 존재하지만 CoW전략 기반의 implementation만 알아보겠다.
 
- 컨테이너를 실행하기 위한 기반 이미지 레이어를 찾는다. 상위 -> 하위 레이어 순으로 탐색을 하며 중간 단계 레이어를 찾으면 이를 재사용하여 이미지 빌드 과정을 최적화 한다.
- 해당 레이어를 컨테이너 레이어의 파일 시스템으로 복사하게 된다 (copy - up 과정)
- 이후, 컨테이너에서 이루어지는 쓰기 작업은 컨테이너 레이어에서 수행되며 이미지 레이어에는 아무 영향을 주지 않는다.
> 드라이버에 따라 차이는 있지만 copy_up연산의 오버헤드가 크게 발생할 수 있다. 파일 시스템이 복잡하고 용량이 클때이다.

### 도커 네트워크의 구조 ( -network --net )

새로운 컨테이너를 실행시켜 보고, default bridge 네트워크를 확인해 보자

<img src="/assets/img/docker/3.png">

아무런 네트워크 설정을 주지않고 새로운 컨테이너를 run 시켰을 때의 모습이다. 다음과 같은 사실을 알 수 있다.

- 내부적으로 게이트웨이 Ip이후의 Ip를 할당받게 된다
- 기본적으로 default 네트워크 브릿지에 연결된다.

오호.. 그러면 방금 실행시켰던 컨테이너 내부의 네트워크 인터페이스를 확인해보자 `docker exec -it {} ifconfig`

<img src="/assets/img/docker/4.png">

아까의 ip가 할당되어 있는 eth0과 lo 인터페이스가 존재했다. 이 서브넷들은 도커 컨테이너 내부에서 할당하는 대역이다. 즉 바깥과 통신하려면 무언가가 필요하게 된다.

#### 궁금증 2 - 어떻게 바깥 네트워크 대역과 통신이 가능할까

통신이 가능하게 하려면 각 컨테이너의 외부 연결을 위해 가상 인터페이스를 생성해 주어야 한다. 하지만 생성해주지 않아도 네트워크는 잘 되었다. 어떻게 이게 가능한걸까 궁금했다.

#### 해답 2 - host
다시, 이번엔 host로 들어와서 인터페이스를 확인해보자.
> 원격 서버에서 ifconfig명령을 치면 바로 실행이 되지 않고, 찾아서 써야한다. 나같은 경우 net-tools를 설치하여 /usr/sbin/ifconfig 에 존재했다

<img src="/assets/img/docker/5.png">

아까와 비교해보자면 docker0과 veth~가 있었다. 이 둘의 역할이 핵심이 될 것이다.

<img src="/assets/img/docker/6.png">

위의 그림이 두 인터페이스의 역할을 잘 설명해준다. 정리해 보자면, 컨테이너를 생성할때 호스트가 자동으로 가상 인터페이스를 생성해준다. 이 인터페이스의 이름이 veth(virtual ethernet)에 해당한다.

<br>
그리고 docker0이라는 'Bridge'도 존재하게 되는데, 이 인터페이스는 각 veth와 바인딩 되어서 호스트 외부 인터페이스와 이어주는 역할을 한다. 이 역시 확인해 볼 수 있다. 이더넷 브리지 명령어로 docker0를 확인해 보자.

<img src="/assets/img/docker/7.png">

오.. 제대로 바인딩 해주고 있었다. 결국 docker0이라는 브리지가 veth 가상 인터페이스의 호스트와 eth0 인터페이스를 이어주는 중간 다리 역할을 해주고 있었다.


#### 해답 2 - 이외 네트워크 종류

1. 브리지 네트워크 + 사용자 정의 브리지 네트워크

`docker network ls`를 통해 기본적으로 3가지 네트워크가 존재함을 알수있다('bridge, host, none') 여기서 bridge는 앞서 확인 했듯이, 컨테이너 생성시 docker0브리지를 자동으로 연결하는데 활용한다.
> 당연히 아무런 설정없이 컨테이너를 생성하면 docker0 브리지를 사용하게 된다.

<br>
새롭게 네트워크를 생성해보고, 다시 ip옵션을 통해 테스트를 해보자.
<br>
```
docker network create --driver bridge newbridge
docker run -d -p 80:80 docker/getting-started --net newbridge
```
<br>

그리고, 다시 한번 호스트 네트워크 인터페이스를 확인해보자(ifconfig)

<img src="/assets/img/docker/8.png">

이처럼 새로운 브리지 형태의 네트워크 대역을 가진 인터페이스가 생성되었다. (172.18.0.1) 이러한 네트워크는 (dis)connect로 간편하게 붙혔다 뗄 수 있으며 --subnet, --ip-range, --gateway 옵션을 따로주어 생성할 수도 있다.

---

2. 호스트 네트워크

이번엔 호스트 네트워크를 이용해 실행해 보자
`docker run -it --net host docker/getting-started ifconfig` 
<br>

이때 찍었던 ifconfig와 host에서 ifconfig를 찍어보면 똑같다...(호스트 머신의 네트워크 인터페이스와 내용이 일치한다) 이 점은 되게 신기했다.
> 이렇게 되면, 호스트 네트워크를 사용하는 컨테이너에서 웹 서버를 구동한다면, 호스트 IP와 컨테이너의 아파치 포트인 80번으로 바로 접근이 가능하겠다.

<img src="/assets/img/docker/9.png">

마치 이런상황이 되는 것이다.

---
3. None 네트워크

`docker run -it --net none docker/getting-started ifconfig` 

이때 lo인터페이스 외에는 존재하지 않는다. 즉 외부와의 단절을 의미한다.

---

4. Container 네트워크

당연히 컨테이너 끼리의 네트워크를 만들어 낼 수 있다. 이 점은 예전에 사용해 보았었다.
`docker run -itd --net container:{containername} ifconfig`

<br>

이렇게 되면 서로의 ifconfig를 찍어보았을 때 동일한 lo와 eth0를 갖게된다.



<img src="/assets/img/docker/10.png">
