---
title: JWT, CSRF, CORS
date: 2021-09-31 13:00:00 +0900
categories: [Etc]
tags: [jwt,security,csrf,cors,session,token]
---

## JWT

기존 스프링 시큐리티를 이용했을때는, 세션방식의 로그인 & 인증만을 진행해 봤지만, 이번 프로젝트에서는 JWT토큰을 이용해 프론트 로그인 및 인증을 진행해보려한다.

### 왜 쓰는가?

HTTP프로토콜을 사용하면서, REST API가 있고 권한이 있는 사용자에게만 엑세스를 준다고 생각해보자.

0. 가장 단순하게 접근해 보자면 API가 사용자 이름과 비밀번호를 요청하는 것이다. 그리고 이를 DB를 통해 확인을 하고, 권한이 있는지 확인을 할 것이다.
> 하지만 HTTP 프로토콜은 stateless하게 동작한다. 즉, 이전 요청에 대해 아무것도 알지 못하기 때문에 새 요청마다 다시 인증을 해야한다.

> 'StateLess'함이라는 것을 처음에는 잘 이해하지 못했지만 점원과 손님의 대화 예시를 떠올리면 되겠다.

<br>

1. 위의 문제를 해결하기 위해 나온 방법으로는 SSS(server side session)이 존재한다.
  - 많이 보았던 Jsession도 이의 일부에 해당한다. 
  - 사용자의 이름과 비밀번호를 확인하고(로그인) 인증된 경우 서버는 세션ID를 DB에 저장하고 이 ID를 클라이언트에게 반환하게 된다.
  - 그 후부터는 클라이언트를 식별하기 위해 세션 ID를 서버로 보내면 된다.
> 이정도 까지만 하더라도 클라이언트 UX는 많이 올라가게 된다. (여러번 요청을 보낼일 없다.)

<img width="600" src="/assets/img/etc/jwt/1.png">

[이미지 출처](https://smoh.tistory.com/347)

2. 하지만 수평확장과 MSA의 흐름을 타면 또 다른 문제를 낳게된다. 
  - 클라이언트가 로드밸런서를 태워 서버로 보낸다고 해보자. 서버가 1개인 경우, 해당 레코드들을 모두 메모리에서 찾을 수 있게된다.
  - 하지만 수평 확장에 따른 서버가 추가되었다고 했을때, 새로운 서버는 해당 레코드를 찾을 수 없게된다.
> 예를 들어 abc라는 세션ID가 구서버에서 인증을 진행했다고 하자. 하지만 새로운 요청을 보냈을때 로드밸런서를 타고 신서버로 들어갔을때는 또 다시 인증을 진행해야한다는 이야기이다.

2-1. 이 상황에서 떠올릴 수 있는 해결책이 존재한다.
  - 서버간 세션의 동기화: 생각을 오래하지 않아도 비효율적이며 까다롭다.
  - 외부의 DB사용(Reddis): 좋은 대안이 될 수 있지만, 관리해야할 구성 요소가 추가된다.
  - HTTP의 stateless 특성을 수용한 토큰방식의 인증

3. 토큰방식의 인증 - JWT에 대해
  - 당사자간의 정보를 JSON객체로 안전하게 전송하기 위해 만들어진 방식에 해당한다. (비)대칭 키를 이용해 디지털 서명이 되어있어 안전함을 더한다.
  - 토큰을 사용하면 세션방식과 달리 서버측의 부하를 낮출 수 있고(저장공간 down), 앞서 이야기한 수평확장 구조에 좀 더 유연하게 대응이 가능하다.

4. JWT 구조 
  - Header, Payload(body), Signature로 이루어져 있다. ( header.payload.signature 형식)

<img width="600" src="/assets/img/etc/jwt/2.png">

[출처](https://jwt.io)

  - 빨간 부분이 헤더에 대한 설명이며 암호화를 하는데 쓰인 알고리즘에 대한 정보가 나와있다. 토큰 자체에 대한 메타데이터라고 보면 될거같다.
  - 보라색 부분은 토큰의 핵심에 해당하는데, 이 안에 subject에 대한 각종 정보(클레임)들이 포함되어 있다.
  - 마지막으로 파란색 부분은 계산된 해시에 해당하는데, 인코딩된 헤더와 페이로드를 합치고 헤더에 나온 알고리즘 + 개인키에 지정된 알고리즘을 사용해 결과값을 해시한다. 이후 이를 Base64URL로 인코딩하게 된다. (알고리즘별로 secretkey에 해당하는 형식과 길이가 다르다!)

5. 좋은것은 알겠지만 단점은?

- 가장 먼저 떠올릴 수 있는 단점은 다음과 같았다.
> payload에 들어가는 필드수가 많아지면 토큰이 비대해질 수 있고, 모든 요청들에 대해 토큰이 전송되면 트래픽에 영향을 줄 수 있다.

> 마지막 암호화에 들어가는 secret-key를 잘 관리해야할 듯 하다.
  - 그리고, 로그아웃에 대해 문제도 있지 않을까 생각한다. 
  - 기존 세션 방식의 경우에는 세션 스토리지에서 해당 세션 값을 날리면 된다. 하지만 이 Stateless한 토큰은 어떻게 처리할 것인가.
> 이를 해결하기 위해 주기가 짧은 access_token과 주기가 긴 refresh_token을 나누어 배부하는 방법이 있다. 그리고 시스템에서 만료된 토큰을 저장해 가리는 방법도 존재한다.
  - 하지만 이 두가지 방법 모두 결국 관리가 필요하다는 것인데.. 이러면 장점을 어느정도 상쇄하지 않을까라고 생각한다(어찌보면 세션으로 관리하는 것이 편할것 같은데..)

## CSRF token & CORS

이 두가지를 많이 보고, 공부했었지만 볼때마다 헷갈리는 것은 사실이다. (인증, 보안 관련부분들은 항상 이런듯 하다..)

### CSRF(Cross Site request Forgery) token

1. CSRF공격을 막기 위해 고안된 토큰에 해당한다. 서버에서는 뷰 페이지를 발행할 때 랜덤으로 생성된 토큰을 같이 준 뒤 사용자 세션에 저장을 해둔다.
> 이후 사용자가 서버에 요청을 보내면, 페이지에 hidden으로 숨어있는 토큰 값을 같이 서버에 전송하게 되며 서버는 이 값이 일치하는 지 확인하여 위조 여부를 판단한다.

> 이 csrf토큰은 모두 1회용이기에, 유출되더라도 악용의 가능성이 거의 없다.

#### 스프링 시큐리티를 사용하면
시큐리티 3.2.0 이후 버전부터 기본값으로 적용이 된다. 모든 POST 방식의 데이터 전송에 토큰 값이 있어야 하고, 이 값이 존재하지 않는다면 에러를 뱉게된다.
> 만약 GET방식도 막아두게 되면 다른 사이트에서 링크를 타고 들어오는 요청이나 Restful API를 처리할 수 없게된다.

- 만약 타임리프와 같은 시큐리티 통합기능을 지원하는 SSR을 사용하면 form에 자동으로이 값이 함께 전송된다. (완전 편했다.)
- 하지만, ajax등으로 보내야 할 경우에는 직접 csrf를 헤더에 붙혀서 보내주어야 한다. (하지만 이것도 어렵지 않게 접근가능하다)
- 스프링 시큐리티가 Default Logout(/logout)의 메서드를 POST로 해둔 이유도 이의 일부에 해당한다. 

### CORS(Cross Origin Resource Sharing)
이전까지는 뷰와 같은 독립적인 프론트엔드단을 두지 않고 프로젝트를 진행했었기에, 이에 대해 크게 신경쓰지 않았지만 통신에 있어 굉장히 중요한 부분이다.
> 프로토콜, 서브도메인, 도메인, 포트중 하나만 달라도 CORS에러가 나게된다.

1. 브라우저 기본값
  - 보안상의 이유로, 브라우저는 cross-origin Http 요청에 대해서 same-origin policy를 적용하여 동작한다.
> 즉, a.com이라는 도메인의 클라이언트에서 리소스를 요청할 때에는 a.com이라는 도메인 서버일 경우에만 CORS문제가 발생하지 않고 정상적으로 동작하게 된다.

> 만약 두 도메인이 서로 다른 값이라면, CORS에 대해 header 설정을 해 주어야 정상적으로 요청 & 응답이 이루어진다.

2. 두가지 리퀘스트
  - 2.1 Simple Request
    - 클라이언트와 서버간에 한번만 요청 및 응답을 주고받게 된다. (Get, head, post만 가능하다) 
    - 커스텀 헤더를 전송할 수 없고, 허용되는 헤더들이 존재한다. 
    - Content-type으로 허용되는 값들이 정해져있다.(json/text/multipart-form)
  - 2.2 Preflight Request
    - Simple Request 조건에 만족하지 않으면 이 방식으로 요청이 된다. Option 메서드를 이용해 서버로 부터 안전한 요청인지 응답을 받고 본 요청을 수행하게 된다.
    - CORS요청시에는 미리 OPTIONS주소로 서버가 CORS를 허용하는지 물어보고 미리 메서드와 헤더를 알려주게 된다.
3. 스프링 시큐리티를 이용한다면
  - 만약 cors에 대한 제어를 놓고싶다면 http를 configure하는 메서드에서 `cors().disable()`을 진행하면 된다.
  - 하지만, 위 방법보다는 프론트엔드의 주소만을 허용해주는 것이 가장 좋을듯하다.

4. 관련 헤더
  - 요청시
    - Origin : 어디서 그 요청이 왔는지에 해당한다. 나는 8000번 포트에서 뷰를 돌리고 있으니, Origin:http://localhost:8000으로 찍힐것이다.
    - Access-Control-Request-Method : Preflight요청을 날려서 실제 보내고자하는 메서드를 알리게된다.
    - Access-Control-Request-Headers : Preflight요청을 날리며, 실제 사용될 헤더들을 보내게 된다.
    - 위 세가지는 모두 Preflight request에 들어간다.
> 응답이 오면 브라우저는 위의 3가지 헤더값과 응답의 헤더를 비교하며 실제 요청을 서버에게 보낼 지 결정한다.

  - 응답시(ALLOW는 요청시의 REQUEST에 대응한다고 생각)
    - Access-Control-Allow-Origin : 요청을 허용하는 origin들을 나타내주게 된다. 만약 모두 허용한다면 *이 표시된다.
    - Access-Control-Allow-Credentials : T/F 값으로 '쿠키와 같은 값을 요청에 넣을 수 있는지'를 알려준다.
    - Access-Control-Expose-Headers : 브라우저가 스크립트에 노출 시킬 헤더의 목록을 명시한다
    - Access-Control-Max-Age : preflight 요청에 대한 응답을 브라우저에서 얼마동안 캐싱하고 있을지 설정할 때 사용한다.
    - Access-Control-Allow-Methods : 어떤 메서드들을 허용할 것인지 명시한다.
    - Access-Control-Allow-Headers : 어떤 헤더들을 허용할 것인지 명시한다.

### 주의점

#### Access-Control-Allow-Origin: *와 Access-Control-Allow-Credentials: true는 함께 사용할 수 없다.

Access-Control-Allow-Credentials: true를 사용하는 경우는 사용자 인증이 필요한 리소스 접근이 필요한 경우에 해당한다. 이때 모든 origin을 허용하게 된다면 CSRF 공격에 매우 취약해 지게 되어 악의적인 사용자가 인증이 필요한 리소스를 마음대로 접근할 수 있게된다.
> 따라서 이를 아예 동작하지 않도록 막아둔 것이다.
