---
title: 문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python
date: 2021-05-19 22:46:00 +0900
categories: [Algorithm, theory]
tags: [algorithm,kmp,string,theory,java,boyer-moore,python3]
mermaid: true
---

# Brute-Force Algorithm
---
문자열을 검색하는 데에, 가장 기초적인 알고리즘에 속한다. 주어진 문자열과 찾고 싶은 문자열이 있을 때, 이를 하나 하나 대조해가며 확인하는 방식이다.
찾고자 하는 문자열의 길이를 M, 주어진 문자열 원본의 길이가 N이라고 할 때 최악의 상황에서 시간 복잡도는 __O(NM)__ 에 달한다.
> 검색할 문자열을 패턴(pattern)이라고 하고, 문자열 원본을 텍스트(text)라고 하겠다.

## 원리
동작원리는 다음과 같다. 텍스트가 'ABCDEFGH'라고 하고, pattern이 'DE'일때이다.

```text
A B C D E F G H
|
D E
```
> 텍스트의 맨 앞부터 탐색을 시작한다(인덱스 0). 여기서 A와 D는 다르므로, 바로 다음칸으로 넘어갈 수 있다.


```text
A B C D E F G H
  |
  D E
```
> 다음 원소(인덱스 1)로 가서 탐색한다. 역시 첫글자부터 다르므로, 다음칸으로 넘어간다.


```text
A B C D E F G H
      | |
      D E
```
> 진행되다가 D를 만나게 되면(인덱스 3). 첫글자가 D로 같으므로, 두번째 글자인 E를 서로 비교한다. 문자열이 같다면 처음 등장한 인덱스인 3을 반환하고, 매칭이 실패할 시 -1을 반환한다.

## 구현
이를 자바로 구현해 보면 다음과 같다.
```java
import java.util.Scanner;
public class BruteForceMatch {

    static int bfMatch(String txt, String pat) {
        int pt = 0; // 문자열(txt)의 포인터에 해당한다.
        int pp = 0; // 패턴(pat)의 포인터에 해당한다.
        while (pt != txt.length() && pp != pat.length()) {
            if (txt.charAt(pt) == pat.charAt(pp)) {
                pt++;
                pp++; // 문자열이 매치된다면 서로의 포인터를 한칸씩 앞으로 해서 비교
            } else {
                pt = pt - pp + 1; // 매치되지 않으면 pp만큼 되돌리고 한칸 앞으로
                pp = 0;
            }
        }
        if (pp == pat.length()) {
            return pt - pp;
        }
        return -1;
    }

    static int bfMatchLast(String txt, String pat) {
        int pt = txt.length() - pat.length(); // 시작 인덱스가 다르다.
        int pp = 0;
        while (pt >= 0 && pp != pat.length()) {
            if (txt.charAt(pt) == pat.charAt(pp)) {
                pt++;
                pp++;
            } else {
                pt = pt - pp - 1; // 뒤에서 부터 탐색하기에, 왼쪽으로 한칸씩
                pp = 0;
            }
        }
        if (pp == pat.length()) {
            return pt - pp;
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        String txt = stdIn.next();
        String pat = stdIn.next();
        int idx = bfMatchLast(txt, pat); // or bfMatch(txt,pat);
        System.out.println(idx);

    }
}
```
> 만약 만족시키는 패턴이 문자열에 여러개 들어있을 경우, 브루트 포스법은 가장 먼저 등장한 패턴의 인덱스를 리턴하게 되는데, 이를 역전 시킨 메서드가 bfMatchLast에 해당한다.

비슷하게 파이썬으로도 쉽게 구현이 가능하다. (마찬가지로 포인터를 이용하였기에 거의 동일 하다.)
```python
from sys import stdin
input = stdin.readline

def bf_match(txt,pat): # in을 이용할 수 있지만 일단 배제.
    pt, pp = 0, 0
    while pt!=len(txt) and pp!=len(pat):
        if txt[pt] == pat[pp]:
            pt += 1
            pp += 1
        else:
            pt = pt - pp + 1
            pp = 0
    if pp == len(pat):
        return pt-pp
    return -1

txt = input().rstrip()
pat = input().rstrip()
print(bf_match(txt,pat))
```
> 두 코드 마찬가지로 종료 조건은 텍스트의 포인터가 끝에 다다르거나, 패턴의 포인터가 끝에 다다를때다. 그리고 패턴을 찾지 못할 경우, -1을 반환한다.

# KMP 알고리즘
---
앞선 브루트포스 알고리즘은 패턴에 없는 문자를 만날 경우에 패턴을 1칸씩 옮긴 다음 다시 패턴의 처음으로 돌아가 검사를 진행했다. KMP 알고리즘은 이를 효율적으로 바꾼 알고리즘으로, 시간 복잡도는 평균적으로 __O(N)__ 까지 줄일 수 있다.

## 원리
만약, 텍스트가 'ZABCABXACCADEF'에서 패턴 'ABCABD'를 찾는다고 가정해보자. 앞선 브루트 포스와는 다르게 KMP알고리즘에서는 텍스트를 효율적으로 이동시키기 위해 표가 필요한데, 이 표는 패턴으로부터 나온다.

```text
ZABCABXACCADEF
|
ABCABD
```
> 0번째 인덱스가 서로 다르므로 일치하지 않는다. 따라서 브루트 포스와 같이 오른쪽으로 한칸 이동시킨다.

```text
ZABCABXACCADEF
 |||||
 ABCABD
```
> 마지막 글자가 맞지 않는다. 하지만 __여기서 텍스트 X의 왼쪽 'AB'가 패턴의 0~1번째 인덱스에 해당하는 글자인 'AB'와 매칭 된다는 것을 이용한다.__

```text
ZABCABXACCADEF
    ||
    ABCABD
```
> 따라서 다음과 같이 패턴의 앞쪽 "AB"를 한번에 이동시키고 (3칸) 패턴의 2번째 인덱스인 'C'부터 원본 텍스트와 비교를 시작한다. 이는 앞서 이야기한 표에 적혀있는 정보에 해당한다.

 그렇다면 이러한 표는 어떻게 작성되는 것일까. 앞서 패턴 ABCABD를 이용해 보겠다.
가장 먼저 패턴과 (길이+1)인 배열을 하나 준비한다. 인덱스(0~len-1)가 아니라 글자 순서(1~len)으로 접근하기 위함이다. 이 배열에는 각 순서에 해당하는 글자(arr[1]은 A에 대한 정보를 이야기)에 정보를 담을 것이다.

```text
1. A | B C A B D  
가장 먼저 arr[1] = 0 으로 초기화한다. 이는 맨 앞글자 A에대한 정보다.

2. A B | C A B D  
이후 arr[2]를 채운다. 이는 B에 대한 정보로, 앞에 같은 B가 등장한적이 없으므로 0으로 채워지게 된다.

3. A B C | A B D
C도 앞선 B와 같은 이유로 arr[3] = 0이 된다. 

4. A B C A | B D
A가 등장하였는데, 이는 
```

