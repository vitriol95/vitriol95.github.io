---
title: 정렬 알고리즘 1 (bubble, selection, insertion) with Java&Python
date: 2021-05-25 22:00:00 +0900
categories: [Algorithm, theory]
tags: [algorithm,theory,java,python3,정렬]
math: true
---

# 버블 정렬 알고리즘
---
가장 단순한 정렬방법으로, 핵심은 __이웃한 두요소__ 의 대소 관계를 비교하고 교환한다는 것이다. 배열 A = [6,4,3,7,1,8,9]를 버블정렬 할 경우 다음과 같은 과정을 따른다.

## 원리
- 6 4 3 7 1 <span style="color:red">9 8</span>
> 맨 뒤에 원소인 9와 8의 비교부터 시작한다. 여기서 9가 8보다 크므로 교환한다.
- 6 4 3 7 <span style="color:red">1 8</span> 9
> 다음 원소인 1과 8을 비교한다. 1 < 8 이므로 교환하지 않는다.
- <span style="color:blue">1</span> 6 4 3 7 8 9
> 모두 한번씩 위의 과정을 거치면 다음과 같이 배열이 바뀐다. 가장 작은 수인 1은 계속되는 교환을 거치며 가장 왼쪽으로 옮겨지게 된다.
- 1 <span style="color:red">6 4 3 7 8 9</span>
> 이미 정렬된 1을 제외하고 2~7번째 원소들만 가지고 위의 과정을 반복한다.

<br>
시간 복잡도의 경우 최악의 경우에는 $$O(N^2)$$에 해당하지만 부분적으로 정렬이 되어있는 배열의 경우 $$O(N)$$ 까지 근접해간다.

## 구현 (Java & Python)
자바와 파이썬으로 구현한 버블정렬은 다음과 같다.
```java
public class BubbleSort {

    // 두 원소를 교체하는 메서드
    static void swap(int[] a, int idx1, int idx2) {
        int t = a[idx1];
        a[idx1] = a[idx2];
        a[idx2] = t;
    }
    
    static void bubbleSort(int[] a, int n) {
        for (int i = 0; i < n-1; i++) {
            for (int j = n - 1; j > i; j--) {
                if (a[j - 1] > a[j]) {
                    swap(a, j - 1, j);
                }
            }
        }
    }

    static void bubbleSort_reverse(int[] a, int n) {
        for (int i = n - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    swap(a, j, j+1);
                }
            }
        }
    }
}
```
> bubbleSort_reverse 메서드의 경우에는 맨 앞원소부터 비교를 진행하는 것으로 가장 큰 원소가 오른쪽에 하나씩 배치된다. 

```python
for i in range(len(arr)-1):
    for j in range(len(arr)-1,i,-1):
        if (a[j-1] > a[j]):
            a[j-1], a[j] = a[j], a[j-1]
```