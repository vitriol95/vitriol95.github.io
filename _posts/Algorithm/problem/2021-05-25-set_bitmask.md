---
title: 백준 집합 11723 with Python
date: 2021-05-25 22:00:00 +0900
categories: [Algorithm, problem]
tags: [algorithm,boj,problem,집합,비트 마스크,python3,백준]
---

# 문제소개
---
__문제출처__ : [백준 - 집합](https://www.acmicpc.net/problem/11723)

<img src="/assets/img/problems/boj11723.PNG">

# 풀이
---
## 접근 과정
눈여겨 보아야 할 곳이 있는데 메모리에 엄청난 제한(4MB)을 두고 있다. 또한 연산의 수가 3,000,000개가 주어지게 되므로 이에 유의해야 한다. 커맨드 중에서 all이나 empty의 경우 계속해서 리스트를 생성해 초기화 시킬시 메모리 초과가 나기 쉽다.

## 비트마스킹
이를 메모리 초과 없이 해결하기 위해서는 '비트'단위로 자료를 다루는 비트마스크 테크닉이 필요하다. 이는 2진수(0,1)로 자료를 다루는데, 대표적인 예는 다음과 같다.

> 다음과 같은 집합이 있다고 가정하자 `A={1,2,3,5}`

여기서 0~5에 대한 숫자가 집합에 포함되어 있는지를 확인하고 싶을때, 가장 단순한 방법으로는 리스트가 있다. `inset = [true,true,true,false,true]` 하지만 이를 2진수로도 나타낼 수 있다. `inset = 11101` 4번째 글자인 0은 숫자 4를 의미하며 0이라는 것은 집합에 포함되지 않음을 이야기한다. 아래는 집합과 그에 대한 이진수를 나타낸다.

```python
A = set(1,2,3,4,8,9,10,15,20)
A_bit = 0b100001000011100011110
# 가장 끝의 0은 숫자 0이 set안에 포함되어있는지를 의미하며 
# 실제 포함되어 있지 않으므로 들어있지않음(0)을 표시한다.
```
> 비트를 이용해 자료를 나타낼 경우 얻을 수 있는 이점으로는 빠른 연산(삭제, 조회, 삽입)이 가능해진다는 것이며 이를 이용하여 다이나믹 프로그래밍(DP)이 용이해진다는 점이 있다. 이 문제에서는 첫번째 장점에 대해 알아보자.

그렇다면 이 문제에서 나오는 커맨드 중 add, remove, check, toggle은 어떤 방식으로 처리하면 될까?

### 원소추가
원소를 추가하는 경우는 비트연산자 << 과 | 를 이용하면된다. << 연산은 왼쪽으로 n칸 비트를 당겨준다는 것이며 다음과 같은 결과를 갖는다.
```python
A = 0b1101
B = 0b0100
print(bin(A<<2))
# 0b110100
print(bin(A>>2))
# 0b11
print(bin(A|B))
# 0b1101

# 원소 추가 (뒤에서 2번째 수를 추가)
print(bin(A|(1<<1)))
# A | 0b10
# 0b1111 
```
> 밀린 두칸의 자리는 0이 채우게 된다. 반대 연산인 >>의 경우는 오른쪽으로 n칸 당기는데 이때는 0이 채우거나 그런 것 없이 수가 사라진다고 보면된다.
 | 는 or 연산으로 매칭되는 두 숫자중 하나가 1이면 1로 채워지게 된다.

### 원소 제거
제거의 경우 & 과 ~ 연산이 추가로 들어간다. & 는 and연산으로 둘다 1일때만 1을 뱉게 된다. ~ 는 not 연산으로 0을 1로, 1을 0으로 바꿔버린다.
```python
A = 0b1101
# 원소 제거 (뒤에서 3번째 원소 제거)
print(bin(A&~(1<<2)))
# A & 1011
# 0b1001
```

### 원소 확인
&와 <<를 이용하면 구현이 가능하다. 이때 결과 값이 0이면 없는 것이된다.
```python
A = 0b1101
# 원소 조회 (뒤에서 3번째 원소 확인)
print(bin(A&(1<<2)))
# A & 100
# 0b100 존재함을 의미 (!=0)
```

### 원소 토글
n번째 수가 있다면 0으로 바꾸고 없다면 1로 바꾸는 것에 해당한다. 여기서 ^ (XOR)연산이 쓰이는데 대응하는 숫자가 서로 다를경우에만 1을 반환한다.
```python
A = 0b1101
# 원소 토글 (뒤에서 3번째 수를)
print(bin(A ^ (1<<2)))
# A ^ 100
# 0b1001
```

## 구현(python3)
```python
import sys
m = int(sys.stdin.readline())
S = 0b0
all_S = 0b111111111111111111111
not_S = 0b000000000000000000000

for i in range(m):
    cmd = sys.stdin.readline().rstrip().split(" ")
    if cmd[0] == "add":
        S = S | (1 << int(cmd[-1]))
    elif cmd[0] == "remove":
        S = S & ~(1 << int(cmd[-1]))
    elif cmd[0] == "check":
        if S & (1 << int(cmd[-1])):
            print(1)
        else:
            print(0)
    elif cmd[0] == "toggle":
        S = S ^ (1 << int(cmd[-1]))

    elif cmd[0] == "all":
        S = S | all_S
    else:
        S = S & not_S
```
> 자세히보면 all_S와 not_S는 21글자로 이루어져 있는데 여기서 숫자와 뒤에서부터의 자리수를 맞추기 위해 일부러 맨 뒤에 한글자를 추가했다.

## 한계 ?
여기서 파이썬의 입력(input)을 쓰게 되면 시간 초과가 나게 되므로 system의 입력(sys.stdin.readline)을 사용해야 한다. 여기서 시간을 더 줄이는 방안은 출력까지 sys.stdout.write로 바꾸게 되면 더 시간을 줄일 수 있다. 