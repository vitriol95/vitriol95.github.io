---
title: 백준 14503 로봇 청소기 with Python (BOJ)
date: 2021-05-22 10:00:00 +0900
categories: [Algorithm, problem]
tags: [algorithm,boj,problem,구현,dfs,시뮬레이션,python3,백준,삼성sw역량테스트]
---

# 문제 소개 - 로봇 청소기
---
__문제 출처__ : [백준 - 로봇 청소기](https://www.acmicpc.net/problem/14503) 삼성SW역량테스트 문제

<img src="/assets/img/problems/boj14503.png">

# 풀이
---
## 접근 과정

> 논외로, 삼성 SW문제들의 공통점(?)이 몇개 있는것 같은데 정말 착실하게 문제 설명을 잘 구현만 하면 된다는 것이다. 번뜩이는 아이디어보다는 이러한 구현 능력을 정말 중요하게 여기는 것을 보여준다. (그리고 평균적으로 코드 량이 길어지는데 이는 내 구현 능력이 부족함을 뜻하는 것 같다..)
<br/>

문제를 읽고 가장먼저 __dfs__ 로 풀어야 겠다라는 생각이 들었다. 문제에서 설명하는 로봇청소기 역시 이러한 원리를 이용해 움직이고 있었기에 이를 떠올리는건 어렵지 않았다. 하지만 가장 큰 문제는 조건 2의 c와 d를 구현하는데에 조금 시간이 걸렸다. 그림으로 설명해 보자면 다음과 같다.

<img src="/assets/img/problems/boj14503-2.PNG">

1. 이 상태에서는 로봇청소기가 북(0)을 바라보고 있는데, 만약 바라보는 곳과 주변이 모두 막혀있을 경우에는 방향을 그대로 유지한채로 나와야 한다.

2. 하지만 조건 2의 a~b를 수행하려면 왼쪽으로 돌며 주변의 상황을 살펴보아야 한다.

이 1과 2를 어떻게 해결하는 것이 이 문제의 구현 핵심이고 나는 이를 다음과 같이 해결하려 하였다.

1. 로봇청소기가 왼쪽으로 회전할 때 마다, 특정한 변수(temp)에 1을 더해준다.

2. 이 temp가 4가 된 경우는 로봇청소기가 한바퀴 돈 것을 의미하며 이 때, 그 방향으로 한칸을 뒤로 빼주면 된다.

이 두가지 메커니즘을 이용하면 구현을 진행할 수 있었다.

## 구현 (python3)

```python
import sys
sys.setrecursionlimit(int(1e5))

def dfs(x, y, d, num):
    global result

    if num != 4:
        if graph[x][y]==0:
            graph[x][y] = -1
            result += 1

        nx = x + dx[3-d]
        ny = y + dy[3-d]

        if 0 <= nx < n and 0 <= ny < m:
            if d == 0:
                nd = 3
            else:
                nd = d-1

            if graph[nx][ny]: # 청소가 되었거나 벽이면
                return dfs(x,y,nd,num+1) # 그 방향으로 틀고 스택을 쌓아줌
            else:
                return dfs(nx,ny,nd,0) # 그 방향으로 이동시키고 2를 다시 시행

    else: # 스택이 모두 쌓여있으면 후진해야함
        if d == 0:
            nx, ny = x + 1, y
        elif d == 1:
            nx, ny = x, y - 1
        elif d == 2:
            nx, ny = x-1, y
        else:
            nx, ny = x, y+1

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] == 1:
                return
            else:
                return dfs(nx,ny,d,0)

    return

n, m = map(int,input().split())
r, c, d = map(int,input().split()) # 0 - 북, 1 - 동, 2 - 남, 3 - 서
graph, result = [], 0
dx, dy = [1,0,-1,0], [0,1,0,-1]

for _ in range(n):
    graph.append(list(map(int,input().split())))

dfs(r,c,d,0)
print(result)
```
> 코드는 __dfs(x,y,d,num)__ 라는 함수가 처음이자 마지막인데 매개변수는 로봇 청소기의 x와 y좌표, 바라보는 방향(d) 그리고 앞서 이야기한 한바퀴 돌았는지 체크하는 변수(num)이 존재한다. 이 num이 4가 되었다는 것은 한바퀴 회전하였음을 의미한다. 

dfs 함수를 보면 가장 먼저 한바퀴를 돌았는지(num=4)에 대한 분기문이 진행된다. 만약 한바퀴를 돌지 않은 경우 _num!=4_ 인경우엔 다음과 같다.

1. 청소가 되어있지 않을때 (그래프가 0일 때) 이를 청소한다 (-1) 그리고 결과 값을 더해준다.

2. 바라보는 방향에 따른 이동할 칸(왼쪽칸) 으로 nx, ny를 맞춘다.

3. 이때 범위를 벗어나거나, 청소가 되어있거나(-1), 벽이라면(1) 현재 방향에서 방향만 틀어주고 num+1을 해준다.

4. 3이 아니라면 그 방향으로 이동시키고 다시 1로 돌아간다. 이 과정에서 num은 0으로 초기화 한다.

_그리고 num = 4가 된다면 다음 과정을 따른다._

1. 방향에 따른 후진할 칸(nx,ny)를 맞춰준다.

2. 후진할 칸이 벽이게 되면 함수를 빠져나온다.

3. 2가 아니라 청소된 칸이면 num = 0으로 초기화 시켜주고 앞선 과정을 다시 반복하게 한다.

## 코드의 한계?

가장 먼저 반복되는 코드가 좀 있어서 이를 좀 더 줄여볼 수 있을 것 같다. 또한 현재는 가로와 세로의 크기가 50x50으로 한정이 되어있지만 더 커진다면 시간초과로부터 자유로울 수 없다.