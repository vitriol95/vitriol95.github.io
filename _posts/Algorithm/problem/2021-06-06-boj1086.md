---
title: 백준 1086 박성원 with Python(pypy3)
date: 2021-06-06 22:00:00 +0900
categories: [Algorithm, problem]
tags: [algorithm,boj,problem,dp,비트 마스크,python3,dfs,백준,다이나믹 프로그래밍]
math: true
---

# 문제소개
---
__문제출처__ : [백준 - 박성원](https://www.acmicpc.net/problem/1086)

<img src="/assets/img/problems/boj1086.JPG">

# 풀이
---
## 접근 과정
개인적으로 어려운 문제였다. 가질 수 있는 순열 후보는 15!에 해당하였기에 완전 탐색은 시간이 굉장히 오래 걸린다. 시간 단축을 위해 메모이제이션을 이용해야 하며 경우의수 또한 비트마스크로 전환하여 구현해야한다.

<br>
메모이제이션이 필요한 이유는 간단하다. `arr = [3,2,1,4,10]`이 입력되었다고 가정하였을 때, 순열의 후보는 321410, 321104 등이 존재하는데 앞선 '321'과정이 겹치게 된다.

<br>
<span style="color:red">가장 먼저</span> dp 테이블에 어떠한 정보가 들어와야 하는지를 알아야 한다. 첫번째로 비트필드를 이용한 dp를 진행해야 하기에, 경로에 대한 정보가 들어와야한다. 이를 열로 설정하였다. 이는 당연히 떠올릴 수 있다. 하지만 행에 어떤 정보를 넣어야 하는지 고민했다. <br> 총 2가지의 행 후보를 꼽아볼 수 있다.

```text
1. 행에 '마지막으로 들어간 수(현재 위치)'를 넣을 경우
2. 행에 나올 수 있는 나머지를 넣을 경우
```
<br>

앞선 [외판원 순회](https://vitriol95.github.io/posts/boj2098/) 문제를 풀고와서 그런지, 1에 굉장히 꽂혀 이로부터 구현하려 했었다. 하지만 이 방법은 좋은 정보를 주지 못한다. 왜냐하면 __이 값을 가지고 할 수 있는 것이 없다__. 앞선 `arr=[3,2,1,4,10]` 의 예시를 들면 마지막으로 들어온 수(현재 위치한 수)가 4라고 하였을 때 다음으로 채워지는 것들에 대해 아무런 정보도 주지 못한다.

<br>
따라서 2로 전환해야 했다. 즉, `dp[i][j] = 비트필드가 j에 해당하고, 이의 나머지가 i일 때, k로 나눠지는 순열 개수` 라는 정보를 담아야 하는 것이다. 나머지 정보를 알고 있다면 __'다음으로 들어온 수에 의해 만들어진 순열' 의 나머지 값__ 에 접근할 수 있기 때문이다.

---
<span style="color:red">두번째로</span> 생각해야 할 것은 비트필드의 역할이다. 만약 비트 10 이 11로 바뀔 때는 순열이 어떻게 된 것일까?

```text
1. 비트 10은 '2' 를 뜻한다.
2. 위의 비트 10이 11로 바뀌었을 때는 '2'뒤에'3'이 오는 것에 해당한다.
따라서 이때의 순열은 '23'에 해당한다.

# 하지만 비트 11은 다른 방법으로도 만들어 진다.
1. 비트 01은 '3'을 뜻한다.
2. 01이 11로 바뀌게 되면 '3'뒤에 '2'가 오는 것이며 이때의 순열은 '32'이다.
```
> 즉 같은 비트필드라도 이는 다른 상태를 표현할 수 있는 것이다. 따라서 비트 11에 해당하는 부분이 채워질때는 앞선 정보(01, 10)에 해당하는 값을 더해주어야한다.

> 이 부분을 조금만 더 생각해보자. 비트필드가 같아도 값이 다를 수 있다. 하지만 우리의 주안점은 'k로 나눈 나머지'에 해당하므로 '행'에 해당하는 값에 따라 2차 분류를 진행하고 있기에 이사실은 별로 중요치 않다.

이를 구현한 코드를 살펴보자.
---

## 구현(pypy3)
```python
import sys, math
input = sys.stdin.readline

def solution(mod,bit):
    if bit == (1 << n) - 1:
        if mod == 0:
            return 1
        return 0
    if dp[mod][bit] != -1:
        return dp[mod][bit]
    temp = 0
    for j in range(n):
        if not bit & (1 << j):
            new_mod = ((mod * mod_10[arr_length[j]]) % k + arr[j]) % k
            temp += solution(new_mod, bit | 1 << j)
    dp[mod][bit] = temp
    return dp[mod][bit]

n = int(input())
arr = [int(input()) for _ in range(n)]
k = int(input())
arr_length = [len(str(i)) for i in arr]
arr = [i % k for i in arr]

mod_10 = [1]
for i in range(50):
    mod_10.append((mod_10[-1]*10) % k)

dp = [[-1]*(1 << n) for _ in range(k)]
answer = solution(0,0)

if answer == 0:
    print('0/1')
else:
    fact = math.factorial(n)
    if answer == fact or k == 1:
        print('1/1')
    else:
        mod = math.gcd(answer, fact)
        print('{}/{}'.format(answer//mod, fact//mod))
```
> solution 함수의 경우 바텀 - 업 방식으로 값을 정의하고 있다.

함수를 보기전에, 자료에 대한 전처리가 필요했다. 무슨말이냐면 우리는 입력받은 수가 `'몇자리 수'` 인가와 `이들이 n자리 수로 옮겨졌을 때의 나머지`가 필요하다.

<br>
예를 들어 문제의 예시와 같이 arr = [5221,40,1,58,9]의 경우를 보자.
'5221'이라는 숫자 뒤에 '40'이라는 수가 추가 될 경우 기존 5221의 나머지또한 자리수가 바뀜에 따라 변경된다. 40은 2자리수에 해당하므로 다음과 같다.
<br>
<div style="text-align: center">$$mod(522140,k) = mod(mod(522100,k) + mod(40,k),k)$$</div>
> mod(522100,k)는 나머지의 성질에 따라 다음과 같이 바꿀 수 있다.
<div style="text-align: center">$$mod(522100,k) = mod(mod(5221,k)*mod(100,k),k)$$</div>
> 이를 구현한 코드가 라인 14에 해당한다.

<br>
그리고 dp 테이블을 -1로 초기화 시켜주고 있다. 이를 0으로 초기화 시키면 '아직 방문하지 않음'을 표현할 수 없기에 런타임 오류 or 시간초과를 뱉을 것이다.

---
## 더 나아가서
'행'을 무엇으로 잡을것인가에서 많은 시간을 쏟았다.. dp에서는 이렇게 필드를 정의하는 능력이 가장 중요함을 깨달았다. 추가로 비트마스크를 이용할 시에는 비트 필드의 역할이 다분화 될 수 있음 또한 느꼈다.

<br>
더 나아가 보자면 이에 대한 역추적 문제 또한 나올 수 있을 것 같다. 이에 대해 조금 더 연구해 보아야겠다.