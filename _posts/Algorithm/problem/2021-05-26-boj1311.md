---
title: 백준 1311 할일 정하기1 with Python
date: 2021-05-26 22:00:00 +0900
categories: [Algorithm, problem]
tags: [algorithm,boj,problem,dp,비트 마스크,python3,백준,다이나믹 프로그래밍]
math: true
---

# 문제소개
---
__문제출처__ : [백준 - 할일 정하기 1](https://www.acmicpc.net/problem/1311)

<img src="/assets/img/problems/boj1311.PNG">

# 풀이
---
## 접근 과정
> 비트마스크에 대한 간단한 정보는 [여기](https://vitriol95.github.io/posts/set_bitmask/)에 적어 두었다.

만약 작업자와 일의 개수가 20개가 되었을 시, 나올 수 있는 조합은 $$20!$$에 해당한다. 다른 작업자의 일은 이전 작업자 들이 어떤일을 맡느냐에 따라 결과가 달라진다. 
<br>즉, __'누가' '어떤 일'을 맡느냐__ 를 나타내고 이를 기록해 두어야 하는데, 이를 모두 표시하기 위해서는 2의 20제곱 크기의 배열이 필요함을 생각할 수 있다.
> 이는 공간/시간적으로 굉장히 비효율적이다.

<br>
앞 문단에서 작성한대로 구현을 하기 위해서는 '그리디'를 이용한 구현보다는 '브루트 포스' 혹은 'DP'의 방법을 이용할 수 있는데 (혹은 DFS도 가능하지 않을 까 생각 했다), 여기서는 DP + 비트마스킹을 이용해 문제를 접근하려 한다. 비트마스크를 쓰는 이유는 간단하다.

```text
1 1 1 = 7 <-- 세 작업자가 모두 일을 하고 있음.
1 0 1 = 5 <-- 두번째 일은 아직 작업자가 배치가 되지 않음.
0 0 0 = 0 <-- 초기 상태
```
> 작업자와 작업의 개수가 3이라고 했을 때 다음과 같이 작업 상태를 나타내기 용이하다.

위의 비트표현들은 다음과 같이 dp로 저장할 수 있다. `dp[비트 표현] = (비트로 표현된 작업상태에서의 최소 비용)` 이 상태에서 작업자들을 하나씩 추가해 보며(행을 추가해보며) 테이블을 갱신해가면 된다.

## 구현 (pypy3로 통과)
```python
graph = {}

def bit_counting(x): 
    # 몇명이 작업에 투입되었는지? --> 비트에 포함된 1의 개수 세기
    answer = 0
    while x:
        answer += (x & 1)
        x >>= 1
    return answer

n = int(input())
dp = [1e9]*(1<<n)
for i in range(n):
    graph[i] = list(map(int,input().split()))

dp[0] = 0
for i in range(1<<n):
    k = bit_counting(i)
    for j in range(n):
        if not i & (1 << j):
            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i]+graph[k][j])

print(dp[-1])
```
> 메모리 낭비를 막기 위해서(열이 굉장히 많다..) dp를 표가 아닌 1차원 배열로 만들고 이를 계속 갱신해 가는 식으로 구현하였다. 2차원 표를 사용하지 않았으므로 몇명이 작업에 투입 되었는지를 기록하는 bit_counting 함수를 추가하였다.

위 코드가 이해하기 난해할 수 있다. 문제의 입력예시 1로 설명해보겠다.
- 가장 먼저 dp[0]에 의해 dp[1(01)], dp[2(10)], dp[4(100)]이 각각 2,3,3 으로 채워지게 된다.
- dp[1(01)]의 경우 dp[3(11)], dp[5(101)]이 채워지는데 이 경우 2번째 작업자(graph[k])의 비용에 의해 각각 4와 6이 채워지게 된다. 
- 같은 방법으로 dp[2]에 의해 dp[4]가 갱신되고 dp[6]이 채워지며 / dp[3]에 의해 dp[7]이 / dp[4]에 의해 dp[5]가 갱신, dp[6]도 갱신 된다.
> 마지막으로 dp[7(111)]을 채우게 되는데 이때 dp[5],dp[3],dp[6]으로 부터 갱신되게 된다.

## 한계?
이 문제의 경우 작업자 - 작업간의 모든 경우의수를 한번씩 훑어보고 있다. 따라서 n이 커지게 되면 이를 저장할 비트공간까지 $$2^n$$으로 커지게 된다. 큰 n에 대해서는 __헝가리안 알고리즘__ 을 적용해야한다.