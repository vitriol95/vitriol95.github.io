<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java &amp; Python" /><meta property="og:locale" content="ko" /><meta name="description" content="Brute-Force 알고리즘 문자열을 검색하는 데에, 가장 기초적인 알고리즘에 속한다. 주어진 문자열과 찾고 싶은 문자열이 있을 때, 이를 하나 하나 대조해가며 확인하는 방식이다. 찾고자 하는 문자열의 길이를 M, 주어진 문자열 원본의 길이가 N이라고 할 때 최악의 상황에서 시간 복잡도는 O(NM) 에 달한다. 검색할 문자열을 패턴(pattern)이라고 하고, 문자열 원본을 텍스트(text)라고 하겠다." /><meta property="og:description" content="Brute-Force 알고리즘 문자열을 검색하는 데에, 가장 기초적인 알고리즘에 속한다. 주어진 문자열과 찾고 싶은 문자열이 있을 때, 이를 하나 하나 대조해가며 확인하는 방식이다. 찾고자 하는 문자열의 길이를 M, 주어진 문자열 원본의 길이가 N이라고 할 때 최악의 상황에서 시간 복잡도는 O(NM) 에 달한다. 검색할 문자열을 패턴(pattern)이라고 하고, 문자열 원본을 텍스트(text)라고 하겠다." /><link rel="canonical" href="https://vitriol95.github.io/posts/string/" /><meta property="og:url" content="https://vitriol95.github.io/posts/string/" /><meta property="og:site_name" content="Vitriol" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-19T22:46:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java &amp; Python" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="QsbP4NOwVkaE8CnHpYOl-qNGhxB9m1RbsrBEefA92ao" /> <script type="application/ld+json"> {"headline":"문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java &amp; Python","dateModified":"2021-05-19T22:46:00+09:00","datePublished":"2021-05-19T22:46:00+09:00","description":"Brute-Force 알고리즘 문자열을 검색하는 데에, 가장 기초적인 알고리즘에 속한다. 주어진 문자열과 찾고 싶은 문자열이 있을 때, 이를 하나 하나 대조해가며 확인하는 방식이다. 찾고자 하는 문자열의 길이를 M, 주어진 문자열 원본의 길이가 N이라고 할 때 최악의 상황에서 시간 복잡도는 O(NM) 에 달한다. 검색할 문자열을 패턴(pattern)이라고 하고, 문자열 원본을 텍스트(text)라고 하겠다.","url":"https://vitriol95.github.io/posts/string/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://vitriol95.github.io/posts/string/"},"@context":"https://schema.org"}</script><title>문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python | Vitriol</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Vitriol"><meta name="application-name" content="Vitriol"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WSY4XYN711"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WSY4XYN711'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Vitriol</a></div><div class="site-subtitle font-italic">기억을 적는 시간</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/vitriol95" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['vitriol951','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> vitriol </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 19, 2021, 10:46 PM +0900" prep="on" > May 19, 2021 <i class="unloaded">2021-05-19T22:46:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4206 words">23 min</span></div></div><div class="post-content"><h1 id="brute-force-알고리즘">Brute-Force 알고리즘</h1><hr /><p>문자열을 검색하는 데에, 가장 기초적인 알고리즘에 속한다. 주어진 문자열과 찾고 싶은 문자열이 있을 때, 이를 하나 하나 대조해가며 확인하는 방식이다. 찾고자 하는 문자열의 길이를 M, 주어진 문자열 원본의 길이가 N이라고 할 때 최악의 상황에서 시간 복잡도는 <strong>O(NM)</strong> 에 달한다.</p><blockquote><p>검색할 문자열을 패턴(pattern)이라고 하고, 문자열 원본을 텍스트(text)라고 하겠다.</p></blockquote><h2 id="원리">원리</h2><p>동작원리는 다음과 같다. 텍스트가 ‘ABCDEFGH’라고 하고, pattern이 ‘DE’일때이다.</p><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C D E F G H
|
D E
</pre></table></code></div></div><blockquote><p>텍스트의 맨 앞부터 탐색을 시작한다(인덱스 0). 여기서 A와 D는 다르므로, 바로 다음칸으로 넘어갈 수 있다.</p></blockquote><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C D E F G H
  |
  D E
</pre></table></code></div></div><blockquote><p>다음 원소(인덱스 1)로 가서 탐색한다. 역시 첫글자부터 다르므로, 다음칸으로 넘어간다.</p></blockquote><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C D E F G H
      | |
      D E
</pre></table></code></div></div><blockquote><p>진행되다가 D를 만나게 되면(인덱스 3). 첫글자가 D로 같으므로, 두번째 글자인 E를 서로 비교한다. 문자열이 같다면 처음 등장한 인덱스인 3을 반환하고, 매칭이 실패할 시 -1을 반환한다.</p></blockquote><h2 id="구현">구현</h2><p>이를 자바로 구현해 보면 다음과 같다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BruteForceMatch</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">txt</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pat</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 문자열(txt)의 포인터에 해당한다.</span>
        <span class="kt">int</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 패턴(pat)의 포인터에 해당한다.</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt</span> <span class="o">!=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pp</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">pt</span><span class="o">++;</span>
                <span class="n">pp</span><span class="o">++;</span> <span class="c1">// 문자열이 매치된다면 서로의 포인터를 한칸씩 앞으로 해서 비교</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 매치되지 않으면 pp만큼 되돌리고 한칸 앞으로</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfMatchLast</span><span class="o">(</span><span class="nc">String</span> <span class="n">txt</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pat</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// 시작 인덱스가 다르다.</span>
        <span class="kt">int</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pp</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">pt</span><span class="o">++;</span>
                <span class="n">pp</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 뒤에서 부터 탐색하기에, 왼쪽으로 한칸씩</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">stdIn</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">txt</span> <span class="o">=</span> <span class="n">stdIn</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">pat</span> <span class="o">=</span> <span class="n">stdIn</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">bfMatchLast</span><span class="o">(</span><span class="n">txt</span><span class="o">,</span> <span class="n">pat</span><span class="o">);</span> <span class="c1">// or bfMatch(txt,pat);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>만약 만족시키는 패턴이 문자열에 여러개 들어있을 경우, 브루트 포스법은 가장 먼저 등장한 패턴의 인덱스를 리턴하게 되는데, 이를 역전 시킨 메서드가 bfMatchLast에 해당한다.</p></blockquote><p>비슷하게 파이썬으로도 쉽게 구현이 가능하다. 2중 for문을 활용하면 된다.</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">stdin</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="k">def</span> <span class="nf">bf_match</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span><span class="n">pat</span><span class="p">):</span> <span class="c1"># in을 이용할 수 있지만 일단 배제.
</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">txt</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">pat</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">bf_match</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span><span class="n">pat</span><span class="p">))</span>
</pre></table></code></div></div><blockquote><p>두 코드 마찬가지로 종료 조건은 텍스트의 포인터가 끝에 다다르거나, 패턴의 포인터가 끝에 다다를때다. 그리고 패턴을 찾지 못할 경우, -1을 반환한다.</p></blockquote><h1 id="kmp-알고리즘">KMP 알고리즘</h1><hr /><p>앞선 브루트포스 알고리즘은 패턴에 없는 문자를 만날 경우에 패턴을 1칸씩 옮긴 다음 다시 패턴의 처음으로 돌아가 검사를 진행했다. KMP 알고리즘은 이를 효율적으로 바꾼 알고리즘으로, 시간 복잡도는 평균적으로 <strong>O(N)</strong> 까지 줄일 수 있다.</p><h2 id="원리-1">원리</h2><p>만약, 텍스트가 ‘ZABCABXACCADEF’에서 패턴 ‘ABCABD’를 찾는다고 가정해보자. 앞선 브루트 포스와는 다르게 KMP알고리즘에서는 텍스트를 효율적으로 이동시키기 위해 표가 필요한데, 이 표는 패턴으로부터 나온다.</p><p>이러한 표를 만들기 위해서 패턴의 접두사, 접미사의 개념을 이용한다. 패턴 ‘ABCABD’의 경우는 다음과 같이 표를 채운다. (한글자 씩 접근)</p><ol><li>‘A’ 의 경우에는 arr[1] = 0 이라고 초기화한다. ( 편의를 위해 인덱스가 아니라 서수로 바꾸었다.)<li>다음으로 ‘AB’를 검사한다. 이미 arr[1] = 0 이라고 초기화 하였고 다음의 B의 경우 겹치는 글자가 없기에 arr[2] = 0 이라고 초기화 된다.<li>‘ABC’의 경우에도 같은 이유로 arr[3] = 0 이 기록된다.<li>‘ABC<span style="color:red">A</span>’ 마지막 A의 경우(접미사) 앞의 A(접두사)와 겹치게 되어 겹치는 글자에 해당하는 arr[4] = 1 이 기록된다.<li>‘ABC<span style="color:red">AB</span>’ 의 경우 접두사인 ‘AB’와 겹치므로 arr[5] = 2가 기록된다.<li>‘ABC<span style="color:red">AB</span>D’ 마지막 글자인 D는 겹치는 접두사가 없으므로 arr[6] = 0 이 기록된다.</ol><p>최종적으로 만들어진 arr = [0, <span style="color:red">0, 0, 0, 1, 2, 0</span>] 가 우리가 사용할 표이다.</p><p>같은 동작 방식으로 패턴 ‘ABCAABBABC’의 표를 작성해 보면 다음과 같은 배열을 얻는다.<br /> arr2 = [0, <span style="color:red">0, 0, 0, 1, 1, 2, 0, 1, 2, 3</span>]</p><p>다시 문제로 돌아와서 ‘ZABCABXACCADEF’를 ‘ABCABD’를 통해 검색해보자</p><hr /><h2 id="검색과정">검색과정</h2><ol><li>브루트포스법과 동일하게 매칭을 시작한다.<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Z A B C A B X A C C A D E F
| 
A B C A B D 
</pre></table></code></div></div><li>첫글자가 매칭되지 않으므로 한칸 앞으로 당겨 매칭을 시작한다.<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Z A B C A B X A C C A D E F
  | | | | |
  A B C A B D 
</pre></table></code></div></div><blockquote><p>여기서 중요한 포인트가 나온다. 앞선 5글자는 모두 매칭에 성공했으나 마지막 글자인 X와 D는 서로 매칭되지 않는다. 브루트 포스라면 여기서 앞선 1~2와 같은 방식으로 한칸 앞으로 당겨 다시 매칭을 시작하지만 우리는 여기서 전에 얻었던 표(arr)의 정보를 이용할 것이다. <strong>D의 앞에있던 문자 ‘AB’와 X의 앞에 있는 문자인 ‘AB’가 동일하다는 점을 기억하자.</strong></p></blockquote><li>마지막으로 맞았던 문자의 정보 ‘B’를 이용하면 되는데, 이를 기록한 값은 arr[5] = 2에 해당한다. 이 2라는 값을 맞지 않았던 원본 텍스트 ‘X’와 비교할 패턴의 인덱스로 활용한다.<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Z A B C A B X A C C A D E F
        | | ?
        A B C A B D
</pre></table></code></div></div><blockquote><p>2 인덱스에 해당하는 패턴의 문자는 C 이므로 이 값이 X와 매칭되게 된다. 이러한 원리를 이용해 KMP는 한칸씩 이동하는 방식에서 진화한 방식이라고 할 수 있다. 앞서 브루트포스의 경우 1칸을 당겼겠지만, KMP의 경우 3칸을 당겨버린 것이다.</p></blockquote></ol><h2 id="구현-1">구현</h2><p>마찬가지로 자바와 파이썬으로 비슷하게 구현해보았다. 크게 2부분으로 나뉜다. 가장 먼저 표를 작성해야하고, 그 이후 실제 매칭을 진행한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KMPmatch</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">kmpMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">txt</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pat</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 1부터 시작하는 것에 주의 (한칸씩 밀리게끔 만들어짐)</span>
        <span class="kt">int</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">skip</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">// 표를 초기화</span>
        <span class="c1">// (서순으로 하였기에 길이가 +1이 된다. 즉, 첫 글자에 대한 정보는 skip[1])</span>

        <span class="c1">// 접두사 및 접미사 매칭</span>
        <span class="n">skip</span><span class="o">[</span><span class="n">pt</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pp</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">skip</span><span class="o">[++</span><span class="n">pt</span><span class="o">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">pp</span><span class="o">;</span> <span class="c1">// 접두사와 접미사가 맞을 시, 길이만큼을 저장해 나간다.</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">skip</span><span class="o">[++</span><span class="n">pt</span><span class="o">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">;</span> <span class="c1">// 처음부터 맞지 않는다면 0을 저장</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="n">skip</span><span class="o">[</span><span class="n">pp</span><span class="o">];</span> <span class="c1">// 중간에 매칭이 안된다면 기존 적어두었던 표를 이용해 회귀</span>
            <span class="o">}</span>
        <span class="o">}</span>
</pre></table></code></div></div><blockquote><p>실제 매칭을 위해서 마치 원본텍스트를 패턴이 이동하는 것처럼, 패턴이 패턴을 이동하는 방식으로 구현하였다. pt의 경우 표를 구성하는 포인터에 해당하며(접미사처럼 움직인다고 보면 된다) pp의 경우 표를 채우기 위해 패턴이 이동하는 포인터(접두사의 역할)에 해당한다. 다음은 실제 매칭을 진행하는 구현부 이다.</p></blockquote><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>        <span class="c1">// 실제 매칭 진행</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt</span> <span class="o">!=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span> <span class="o">!=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pp</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">pt</span><span class="o">++;</span>
                <span class="n">pp</span><span class="o">++;</span> 
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">pt</span><span class="o">++;</span> <span class="c1">// 아얘 처음부터 틀린 경우에는 전체 포인터만 한칸 이동시킴</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="n">skip</span><span class="o">[</span><span class="n">pp</span><span class="o">];</span> <span class="c1">// 중간에 틀렸다면 pp를 테이블을 이용해 이동시킨다.</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>표를 작성하는 부분과 굉장히 유사함을 알 수 있다. 핵심은 else에 해당하는 pp = skip[pp] 에 해당하는 부분인데, 이는 앞선 검색과정의 3번 항목에 해당한다.</p></blockquote><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">stdin</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="k">def</span> <span class="nf">kmp_match</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span><span class="n">pat</span><span class="p">):</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pt</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">pt</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pat</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">pp</span><span class="p">]:</span> <span class="c1"># 접두사와 접미사가 서로 맞을때
</span>            <span class="n">pt</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pp</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">elif</span> <span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 처음부터 틀릴 때
</span>            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>
        
    <span class="c1"># 실제 탐색 과정
</span>    <span class="n">pt</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pt</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pp</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>    
        <span class="k">if</span> <span class="n">txt</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">pp</span><span class="p">]:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pp</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pp</span> 
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">text</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">kmp_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="n">pattern</span><span class="p">))</span>
</pre></table></code></div></div><blockquote><p>처음 이해하기 굉장히 쉽지 않은데, 포인터가 어떻게 이동하게 되는지 파악만 하면 해결될것이라 생각한다.</p></blockquote><h1 id="boyer-moore-알고리즘">Boyer-Moore 알고리즘</h1><p>KMP 법의 경우에는 복잡하기도 하고, 일반적으로 알려진 사실로는 Boyer-Moore 알고리즘이 KMP보다 성능이 비슷하거나 우수하게 알려져 있다. 그리고 실제로 문자열 검색에 널리 사용하는 알고리즘이라고 한다.</p><hr /><h2 id="원리-2">원리</h2><p>Boyer-Moore 알고리즘은 이전까지의 문자열 검색 알고리즘 들과 다르게, 패턴의 뒤에서부터 검색을 진행한다. 하지만 마찬가지로 건너 뛰는 과정이 존재하기에 패턴으로 부터 표를 얻어야한다는 것은 KMP와 동일하다. ‘ABCXDEZCABACABAC’ 에서 ‘ABAC’를 검색한다고 상황을 가정해 보자.</p><ol><li>맨 뒤에서 부터 검색을 진행하는데, 마지막글자인 X와 C가 다르기에 넘어간다.<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C X D E Z C A B A C A B A C
.     |
A B A C 
</pre></table></code></div></div><li>하지만, 위의 2방법들과 다르게 한칸 넘어가는 것이 아니라 <strong>‘X’라는 문자는 패턴에 없는 것을 이용해 패턴의 길이인 4칸을 넘겨 버린다</strong><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C X D E Z C A B A C A B A C
.           | |
.       A B A C 
</pre></table></code></div></div><blockquote><p>따라서 패턴은 다음과 같이 옮겨지게 되고 마지막 글자인 C가 일치하므로 그 이전 글자인 Z와 A를 매칭 시킨다.</p></blockquote><li>마찬가지로 Z라는 문자열은 존재하지 않기에 현재 있는 위치(Z)를 기준으로 하여 패턴의 길이 값인 4칸을 이동시킨다.<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C X D E Z C A B A C A B A C
.                   |
.             A B A C 
</pre></table></code></div></div><blockquote><p>문자가 매칭되지 않는다. 하지만 A라는 글자는 패턴에 존재하므로 끝에서 부터 가장 가까운 A의 위치와 매칭되게끔 패턴을 이동시킨다 (1칸)</p></blockquote><li>매칭에 성공하게 된다.(C-&gt;A-&gt;B-&gt;A 순서로 검사 진행)<div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C X D E Z C A B A C A B A C
.               | | | |
.               A B A C 
</pre></table></code></div></div></ol><h2 id="구현-2">구현</h2><p>표를 작성하는 원리를 코드를 통해서 살펴보도록 하자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoyerMooreMatch</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bmMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">txt</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pat</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">txtLen</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">patLen</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">patLen</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">pp</span><span class="o">;</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">skipMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">txtLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">skipMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">patLen</span><span class="o">);</span> <span class="c1">// 초기화</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">patLen</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">skipMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">),</span><span class="n">patLen</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 매핑</span>
        <span class="o">}</span>
</pre></table></code></div></div><p>위의 부분이 표를 만드는 과정에 해당한다. 초기화 과정은 모든 문자에 대해 패턴의 길이만큼 값을 저장해 주었고 매핑의 경우에는 그 문자가 뒤에서 몇번째에 위치하는지에 대한 정보 값을 집어넣어 주었다. (즉 인덱스의 역순이 되는 것이다.)</p><blockquote><p>해쉬맵의 경우, 고유한 키 값에 따른 value는 하나밖에 저장되지 않는다. 예를 들어 패턴이 ‘ABCABD’인 경우 skipMap[‘A’]에는 앞의 A에 해당하는 5가 들어가는 것이 아니라, 뒤에 등장한 A인 2가 덮어 씌워지게 된다. 다음은 실제 매칭 과정을 보자.</p></blockquote><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>        <span class="c1">// 실제 탐색 과정</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt</span> <span class="o">&lt;</span> <span class="n">txtLen</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">patLen</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)</span> <span class="o">==</span> <span class="n">pat</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pp</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">pt</span><span class="o">;</span>
                    <span class="c1">// 패턴의 포인터가 0으로 와야 매칭성공</span>
                <span class="o">}</span>
                <span class="n">pp</span><span class="o">--;</span>
                <span class="n">pt</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">pt</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">skip</span><span class="o">[</span><span class="n">txt</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pt</span><span class="o">)],</span> <span class="n">patLen</span> <span class="o">-</span> <span class="n">pp</span><span class="o">);</span> 
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">stdIn</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">txt</span> <span class="o">=</span> <span class="n">stdIn</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">pat</span> <span class="o">=</span> <span class="n">stdIn</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bmMatch</span><span class="o">(</span><span class="n">txt</span><span class="o">,</span> <span class="n">pat</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>가장 핵심이 되는 부분은 12번째 라인에 해당한다. 매칭이 되지 못한 경우 포인터를 이동시키는데, 원리부분의 1과 같은 상황인 경우 pt가 3에서 7로 이동하게 되고, 2의 경우 pt는 6에서 10으로 이동하게 된다. 3의 과정에서는 skip[pt]의 값이 skip[‘A’] = 1에 해당되기에 pt가 10에서 11로 이동한다.</p></blockquote><p>그럼 <code class="language-plaintext highlighter-rouge">pt+=skip[txt.charAt(pt)]</code>만 있으면 될 것 같은데, 뒤의 인자는 정체가 무엇일까. 이는 <strong>non-shift</strong> 를 막기 위해 존재한다. 예를 들어 다음과 같은 상황이 존재한다.</p><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>A B C D D ~ ~ ~ (원본 텍스트) 
.     | |
A C B A D      (패턴)
</pre></table></code></div></div><blockquote><p>이러한 경우(pt=3) 패턴과 매칭이 되지 않기에 skip[txt.charAt(pt)]는 skip[‘D’]에 해당한다. 하지만 skip[‘D’]에는 0이라는 값이 저장이 되어있어, 아얘 전진을 하지 못하는 상황이 발생된다. 따라서 patLen-pp에 해당하는 2라는 값이 그에 대한 bound역할을 해주는 것이다. (2칸을 검사 했으니 그만큼 패스시킨다.)</p></blockquote><p>마지막으로 파이썬으로 구현하면 다음과 같다.</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">stdin</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="k">def</span> <span class="nf">bm_match</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span><span class="n">pat</span><span class="p">):</span>

    <span class="n">txtlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="n">patlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span>
    <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">txtlen</span><span class="p">):</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">txt</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">patlen</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">patlen</span><span class="p">):</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># 실제 탐색 부분
</span>    <span class="k">while</span> <span class="n">pt</span> <span class="o">&lt;</span> <span class="n">txtlen</span><span class="p">:</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">patlen</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">txt</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">pp</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pt</span>
            <span class="n">pt</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">pp</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">pt</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">txt</span><span class="p">[</span><span class="n">pt</span><span class="p">]],</span><span class="n">patlen</span><span class="o">-</span><span class="n">pp</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">txt</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="n">pat</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">rstrip</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm_match</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">pat</span><span class="p">))</span>
</pre></table></code></div></div><h1 id="참고자료">참고자료</h1><hr /><p>출처 : <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791163030072">Do it! 자료구조와 함께 배우는 알고리즘 입문 - 자바편</a> <br /> 출처 : <a href="https://bowbowbow.tistory.com/6">https://bowbowbow.tistory.com/6</a> 도움이 정말 많이 되었습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/algorithm/'>Algorithm</a>, <a href='/categories/theory/'>theory</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >algorithm</a> <a href="/tags/kmp/" class="post-tag no-text-decoration" >kmp</a> <a href="/tags/string/" class="post-tag no-text-decoration" >string</a> <a href="/tags/theory/" class="post-tag no-text-decoration" >theory</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/boyer-moore/" class="post-tag no-text-decoration" >boyer-moore</a> <a href="/tags/python3/" class="post-tag no-text-decoration" >python3</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python - Vitriol&url=https://vitriol95.github.io/posts/string/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python - Vitriol&u=https://vitriol95.github.io/posts/string/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=문자열 알고리즘(Brute Force, KMP, Boyer-Moore) with Java & Python - Vitriol&url=https://vitriol95.github.io/posts/string/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/batchbase1/">스프링 배치 - 1 스프링 배치란?</a><li><a href="/posts/batchbase2/">스프링 배치 - 2 DB 스키마에 대한 이해</a><li><a href="/posts/batchbase3/">스프링 배치 - 3 도메인 뜯어보기(JOB)</a><li><a href="/posts/batchbase4/">스프링 배치 - 4 도메인 뜯어보기(STEP)</a><li><a href="/posts/batchbase5/">스프링 배치 - 5 청크 지향 처리</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/sorting/"><div class="card-body"> <span class="timeago small" > May 25, 2021 <i class="unloaded">2021-05-25T22:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>정렬 알고리즘 1 (bubble, selection, insertion) with Java&Python</h3><div class="text-muted small"><p> 버블 정렬 알고리즘 가장 단순한 정렬방법으로, 핵심은 이웃한 두요소 의 대소 관계를 비교하고 교환한다는 것이다. 배열 A = [6,4,3,7,1,9,8]를 버블정렬 할 경우 다음과 같은 과정을 따른다. 원리 6 4 3 7 1 9 8 맨 뒤에 원소인 9와 8의 비교부터 시작한다. 여기서 9가 8보다 크므로 교환한다. ...</p></div></div></a></div><div class="card"> <a href="/posts/boj5670/"><div class="card-body"> <span class="timeago small" > Jun 10, 2021 <i class="unloaded">2021-06-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>백준 5670 휴대폰 자판 with Python, Java</h3><div class="text-muted small"><p> 문제소개 문제출처 : 백준 - 휴대폰 자판 풀이 접근 과정 역시 트라이 자료구조를 이용한 문자열 탐색문제에 해당한다. 이전 문제와 굉장히 유사했기에 코드도 이와 비슷한 모습을 띄고 있다. 하지만 처리해야할 상황이 조금 다르다. 문제에서 주어진 예시상황을 보며 이야기해보자. 트라이는 다음과 같이 자료를 저장할 것이다. 가장 먼저, ‘...</p></div></div></a></div><div class="card"> <a href="/posts/sorting2/"><div class="card-body"> <span class="timeago small" > Jul 1, 2021 <i class="unloaded">2021-07-01T22:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>정렬 알고리즘 2 (quick, merge, heap) with Java</h3><div class="text-muted small"><p> 퀵 정렬 이론상 가장 빠른 정렬 알고리즘의 하나로 널리 사용되고 있다. 원리 하나의 피벗(pivot)을 선택하여 이보다 큰 값과 작은 그룹으로 나누어 분할한 뒤, 정렬을 이어나가는 방식이다. merge sort와는 다르게 피벗에 따라 나누어지는 원소 개수가 달라지게 되므로 비균등하게 분할을 진행하게 된다. A = [5,7,1,4,6,2,3,9,...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/boj4803/" class="btn btn-outline-primary" prompt="Older"><p>백준 4803 트리 with Python</p></a> <a href="/posts/polygon_area/" class="btn btn-outline-primary" prompt="Newer"><p>백준 2166 다각형의 면적 with Python (BOJ)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">vitriol</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://vitriol95.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
