<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="코틀린의 CompanionObject vs 자바 Static" /><meta property="og:locale" content="ko" /><meta name="description" content="Kotlin + Companion Object 출처 출처2" /><meta property="og:description" content="Kotlin + Companion Object 출처 출처2" /><link rel="canonical" href="https://vitriol95.github.io/posts/kotlinCompanionObject/" /><meta property="og:url" content="https://vitriol95.github.io/posts/kotlinCompanionObject/" /><meta property="og:site_name" content="Vitriol" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-04T13:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="코틀린의 CompanionObject vs 자바 Static" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="QsbP4NOwVkaE8CnHpYOl-qNGhxB9m1RbsrBEefA92ao" /> <script type="application/ld+json"> {"headline":"코틀린의 CompanionObject vs 자바 Static","dateModified":"2021-10-04T13:00:00+09:00","datePublished":"2021-10-04T13:00:00+09:00","description":"Kotlin + Companion Object 출처 출처2","url":"https://vitriol95.github.io/posts/kotlinCompanionObject/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://vitriol95.github.io/posts/kotlinCompanionObject/"},"@context":"https://schema.org"}</script><title>코틀린의 CompanionObject vs 자바 Static | Vitriol</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Vitriol"><meta name="application-name" content="Vitriol"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WSY4XYN711"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WSY4XYN711'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Vitriol</a></div><div class="site-subtitle font-italic">기억을 적는 시간</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/vitriol95" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['vitriol951','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>코틀린의 CompanionObject vs 자바 Static</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>코틀린의 CompanionObject vs 자바 Static</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> vitriol </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Oct 4, 2021, 1:00 PM +0900" prep="on" > Oct 4, 2021 <i class="unloaded">2021-10-04T13:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2053 words">11 min</span></div></div><div class="post-content"><h2 id="kotlin--companion-object">Kotlin + Companion Object</h2><p><a href="https://www.bsidesoft.com/8187">출처</a> <a href="https://kotlinlang.org/docs/object-declarations.html#using-anonymous-objects-as-return-and-value-types">출처2</a></p><p><br /></p><p>코틀린에서의 Companion Object는 자바의 Static과 엄연히 다르다. 그렇다면 왜 기존의 Static을 쓰지 않고 코틀린에와서 이렇게 넘어오게 됬는지, 그 연유를 찾아 올라가면 알 수 있지 않을까?</p><h3 id="자바의-static--코틀린의-object">자바의 Static &amp; 코틀린의 Object</h3><p>자바에서의 static이 붙은 변수나 메서드를 각각 클래스 변수, 클래스 메서드라고 부르고 있다. static이 붙은 멤버는 클래스가 메모리에 적재될 때 자동으로 함께 생성되므로 인스턴스 생성 없이 접근이 가능하다.</p><blockquote><p>이외는 인스턴스 변수, 인스턴스 메서드라고 이야기한다.</p></blockquote><p><br /> 코틀린에서도 이와 비슷한 논리로 companion object를 사용한 경험이 있다. 아래의 TEST나 method는 외부에서 . 을 이용해 접근이 가능하다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Vitriol</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">TEST</span> <span class="p">=</span> <span class="s">"test"</span>
        <span class="k">fun</span> <span class="nf">method</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="mi">10</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;){</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nc">TEST</span><span class="p">);</span>    <span class="c1">//test</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>   <span class="c1">//11</span>
<span class="p">}</span>
</pre></table></code></div></div><p>하지만 여기서 눈여겨볼 선언방식이 나타난다. 이는 Companion ‘Object’라는 것이다. 코틀린은 싱글턴을 언어 수준에서 만들어 준다. class 키워드 대신 object키워드로 생성할 경우 이는 싱글턴 방식으로 관리가 된다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">object</span> <span class="nc">VitriolSingleton</span><span class="p">{</span>
    <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 VitriolSingleton의 속성이다."</span>
    <span class="k">fun</span> <span class="nf">method</span><span class="p">()</span> <span class="p">=</span> <span class="s">"나는 VitriolSingleton의 메소드다."</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;){</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">VitriolSingleton</span><span class="p">.</span><span class="n">prop</span><span class="p">);</span>    <span class="c1">//나는 VitriolSingleton의 속성이다.</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">VitriolSingletonm</span><span class="p">.</span><span class="nf">method</span><span class="p">());</span>   <span class="c1">//나는 VitriolSingleton의 메소드다.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이는 특정 클래스나 인터페이스를 확장해 만들 수 있으며 위처럼 선언문이 아니라 표현식으로 생성할 수 있다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">open</span> <span class="kd">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">open</span> <span class="kd">val</span> <span class="py">y</span><span class="p">:</span> <span class="nc">Int</span> <span class="p">=</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">B</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>

<span class="kd">val</span> <span class="py">ab</span><span class="p">:</span> <span class="nc">A</span> <span class="p">=</span> <span class="kd">object</span> <span class="err">: </span><span class="nc">A</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">val</span> <span class="py">y</span> <span class="p">=</span> <span class="mi">15</span>
<span class="p">}</span>
</pre></table></code></div></div><p>다시 돌아오면 companion object는 클래스 내부에 정의되는 object의 특수한 형태라는 것이다.</p><h3 id="companion-object이-static과-다른-이유-1">Companion Object이 static과 다른 이유 (1)</h3><p>이 코드를 다시 한번 확인해 보자.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Vitriol</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">TEST</span> <span class="p">=</span> <span class="s">"test"</span>
        <span class="k">fun</span> <span class="nf">method</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="mi">10</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;){</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nc">TEST</span><span class="p">);</span>    <span class="c1">//test</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>   <span class="c1">//11</span>
<span class="p">}</span>
</pre></table></code></div></div><p>main 함수에서 보면 Vitriol.TEST는 사실 <code class="language-plaintext highlighter-rouge">Vitriol.Companion.TEST</code>의 축약본이다. 실제 import되는 문구를 확인해보면 더욱 명확해진다. 즉, companion object는 static과 다르게 클래스가 메모리에 적재되면서 함께 생성되는 동반 객체이고 이는 <code class="language-plaintext highlighter-rouge">클래스.Companion</code>으로 접근이 가능하다.</p><blockquote><p>이렇게 언어적으로 지원하는 축약 표현 때문에 companion object가 static과 혼동이 되는 것이다.</p></blockquote><h3 id="companion-object이-static과-다른-이유-2">Companion Object이 static과 다른 이유 (2)</h3><p>Companion Object를 가지고 다음과 같이 코드를 작성할 수도 있다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;){</span>
   <span class="kd">val</span> <span class="py">comp1</span> <span class="p">=</span> <span class="nc">Vitriol</span><span class="p">.</span><span class="nc">Companion</span> 
    <span class="nf">println</span><span class="p">(</span><span class="n">comp1</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp1</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>
    <span class="kd">val</span> <span class="py">comp2</span> <span class="p">=</span> <span class="nc">Vitriol</span> 
    <span class="nf">println</span><span class="p">(</span><span class="n">comp2</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp2</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>
<span class="p">}</span>
</pre></table></code></div></div><p>자바의 Static이라면 사용하지 못할 코드들이다. 이것이 가능한 이유는 companion ‘object’에 해당하기 때문이다. 객체이므로 변수에 할당 할 수 있고, 이의 멤버들에 접근이 가능한 것이다. 이에 추가로 축약 표현 덕분에 <code class="language-plaintext highlighter-rouge">val comp2 = Vitriol</code>과 같은 표현이 가능해진다.</p><blockquote><p>Static키워드만으로는 클래스 멤버를 companion object처럼 하나의 독립된 객체로 여길 수 없다.! 이것또한 큰 차이점에 해당한다.</p></blockquote><h3 id="companion-object이-static과-다른-이유-3">Companion Object이 static과 다른 이유 (3)</h3><p>(2)와 상당히 연결되는 부분에 해당한다. 객체이므로 새로운 이름을 할당해 줄 수 있다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Vitriol</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="nc">MyCompanion</span><span class="p">{</span>  <span class="c1">// -- (1)</span>
        <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 Companion object의 속성이다."</span>
        <span class="k">fun</span> <span class="nf">method</span><span class="p">()</span> <span class="p">=</span> <span class="s">"나는 Companion object의 메소드다."</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nc">MyCompanion</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Vitriol</span><span class="p">.</span><span class="nc">MyCompanion</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>

    <span class="kd">val</span> <span class="py">comp1</span> <span class="p">=</span> <span class="nc">Vitriol</span><span class="p">.</span><span class="nc">MyCompanion</span> 
    <span class="nf">println</span><span class="p">(</span><span class="n">comp1</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp1</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>

    <span class="kd">val</span> <span class="py">comp2</span> <span class="p">=</span> <span class="nc">Vitriol</span> 
    <span class="nf">println</span><span class="p">(</span><span class="n">comp2</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp2</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>

    <span class="kd">val</span> <span class="py">comp3</span> <span class="p">=</span> <span class="nc">Vitriol</span><span class="p">.</span><span class="nc">Companion</span> <span class="c1">// 에러</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp3</span><span class="p">.</span><span class="n">prop</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">comp3</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이름을 지어주었다 하더라도, 클래스이름만으로 접근할 수 있지만 기본 참조이름 (.Companion)으로는 접근할 수 없게된다. 이 역시 자바의 static으로는 불가능한 영역에 해당한다.</p><p><br /></p><p>+) 추가로 우리는 <code class="language-plaintext highlighter-rouge">val comp2 = Vitriol</code> 처럼 클래스이름으로 companion Object에 접근하는 것을 확인했다. 이렇게 되면 클래스 내에 2개이상의 companion Object가 올 수 있을까?</p><blockquote><p>당연히 불가능하다. 클래스 명만으로 companion object객체를 참조할 수 있기때문에 이를 애초부터 막아두었다. 이름을 별도로 부여해도 마찬가지이다!</p></blockquote><p><br /> 인터페이스에서도 companion object를 정의해 줄 수 있다. 물론 이점은 jdk8로 넘어와서 인터페이스에서 static method를 정의할 수 있는 점과 비슷하다.</p><blockquote><p>인터페이스에서 정의된 static들은 모두 final에 해당하며 이들의 override는 이루어질 수 없다. 코틀린에서 이 점은 어떻게 될까.</p></blockquote><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">open</span> <span class="kd">class</span> <span class="nc">Parent</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">parentProp</span> <span class="p">=</span> <span class="s">"나는 부모값"</span>
    <span class="p">}</span>
    <span class="k">fun</span> <span class="nf">method0</span><span class="p">()</span> <span class="p">=</span> <span class="n">parentProp</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Child</span><span class="p">:</span><span class="nc">Parent</span><span class="p">(){</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">childProp</span> <span class="p">=</span> <span class="s">"나는 자식값"</span>
    <span class="p">}</span>
    <span class="k">fun</span> <span class="nf">method1</span><span class="p">()</span> <span class="p">=</span> <span class="n">childProp</span>
    <span class="k">fun</span> <span class="nf">method2</span><span class="p">()</span> <span class="p">=</span> <span class="n">parentProp</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">child</span> <span class="p">=</span> <span class="nc">Child</span><span class="p">()</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method0</span><span class="p">())</span> <span class="c1">//나는 부모값</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method1</span><span class="p">())</span> <span class="c1">//나는 자식값</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method2</span><span class="p">())</span> <span class="c1">//나는 부모값</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위 처럼 부모 / 자식의 companion object가 다른 이름이라면 자식이 부모의 companion object 멤버를 직접 참조할 수 있게 된다.</p><blockquote><p>사실 이점은 상속이라는 개념보다는 ‘참조’가 더 어울린다. 이미 컴파일 타임에 생성된 것을 super나 Parent.~ 로 직접 조회하는 것과 다를 것이 없다.</p></blockquote><p>만약 서로의 companion object가 같은 prop을 갖는다면 어떻게 될까</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">open</span> <span class="kd">class</span> <span class="nc">Parent</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 부모"</span>
    <span class="p">}</span>
    <span class="k">fun</span> <span class="nf">method0</span><span class="p">()</span> <span class="p">=</span> <span class="n">prop</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Child</span><span class="p">:</span><span class="nc">Parent</span><span class="p">(){</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="nc">ChildCompanion</span><span class="p">{</span> 
        <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 자식"</span>
    <span class="p">}</span>
    <span class="k">fun</span> <span class="nf">method1</span><span class="p">()</span> <span class="p">=</span> <span class="n">prop</span>
    <span class="k">fun</span> <span class="nf">method2</span><span class="p">()</span> <span class="p">=</span> <span class="nc">ChildCompanion</span><span class="p">.</span><span class="n">prop</span>
    <span class="k">fun</span> <span class="nf">method3</span><span class="p">()</span> <span class="p">=</span> <span class="nc">Companion</span><span class="p">.</span><span class="n">prop</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">child</span> <span class="p">=</span> <span class="nc">Child</span><span class="p">()</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method0</span><span class="p">())</span> <span class="c1">//나는 부모</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method1</span><span class="p">())</span> <span class="c1">//나는 자식</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method2</span><span class="p">())</span> <span class="c1">//나는 자식</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="nf">method3</span><span class="p">())</span> <span class="c1">//나는 부모 (!)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>실제 main부분의 method1을 보면 자식클래스의 companion object가 되어있다. 이것은 자바에서와 마찬가지로 ‘상속하여 override’ 된것이 아니라, shadowing한 것에 해당한다.</p><p><br /> 추가로 ! 부분을 보면 기존의 Companion은 자식의 것이 아니다. (ChildCompanion이라는 이름을 붙혔기 때문에)여기서 Companion은 부모가 되므로 부모의 prop을 가져오게 된다.</p><blockquote><p>만약 부모의 companion object에도 이름을 붙히게 되면 method3은 컴파일 에러를 뱉는다.</p></blockquote><blockquote><p>결론을 이야기하자면, 부모 자식간의 companion object에 정의된 멤버는 자식입장에서 접근할 수 있지만, 같은 이름을 사용하게 되면 shadowing되어 자식의 값으로 감추어짐을 알 수 있었다.</p></blockquote><p><br /></p><p>마지막으로 companion object와 다형성을 엮어 볼 수 있다.</p><div class="language-kotlin highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">open</span> <span class="kd">class</span> <span class="nc">Parent</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 부모"</span>
    <span class="p">}</span>
    <span class="k">open</span> <span class="k">fun</span> <span class="nf">method</span><span class="p">()</span> <span class="p">=</span> <span class="n">prop</span> 
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Child</span><span class="p">:</span><span class="nc">Parent</span><span class="p">(){</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="s">"나는 자식"</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">method</span><span class="p">()</span> <span class="p">=</span> <span class="n">prop</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Parent</span><span class="p">().</span><span class="nf">method</span><span class="p">())</span> <span class="c1">//나는 부모</span>
    <span class="nf">println</span><span class="p">(</span><span class="nc">Child</span><span class="p">().</span><span class="nf">method</span><span class="p">())</span> <span class="c1">//나는 자식</span>
    <span class="kd">val</span> <span class="py">p</span><span class="p">:</span><span class="nc">Parent</span> <span class="p">=</span> <span class="nc">Child</span><span class="p">()</span>
    <span class="nf">println</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">method</span><span class="p">())</span> <span class="c1">//나는 자식</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Child의 method()에서는 shadowing이 되어 ‘나는 자식’이라는 문구를 내놓게 된다. 마지막으로 p.method()의 경우에도 다형성에 의해 ‘나는 자식’이라는 문구를 던지게 된다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/kotlin/'>Kotlin</a>, <a href='/categories/kotlin-study/'>kotlin_study</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kotlin/" class="post-tag no-text-decoration" >kotlin</a> <a href="/tags/jvm/" class="post-tag no-text-decoration" >jvm</a> <a href="/tags/companionobject/" class="post-tag no-text-decoration" >companionObject</a> <a href="/tags/static/" class="post-tag no-text-decoration" >static</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=코틀린의 CompanionObject vs 자바 Static - Vitriol&url=https://vitriol95.github.io/posts/kotlinCompanionObject/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=코틀린의 CompanionObject vs 자바 Static - Vitriol&u=https://vitriol95.github.io/posts/kotlinCompanionObject/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=코틀린의 CompanionObject vs 자바 Static - Vitriol&url=https://vitriol95.github.io/posts/kotlinCompanionObject/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/batchbase1/">스프링 배치 - 1 스프링 배치란?</a><li><a href="/posts/batchbase2/">스프링 배치 - 2 DB 스키마에 대한 이해</a><li><a href="/posts/batchbase3/">스프링 배치 - 3 도메인 뜯어보기(JOB)</a><li><a href="/posts/batchbase4/">스프링 배치 - 4 도메인 뜯어보기(STEP)</a><li><a href="/posts/batchbase5/">스프링 배치 - 5 청크 지향 처리</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/extensionFunc/"><div class="card-body"> <span class="timeago small" > Oct 4, 2021 <i class="unloaded">2021-10-04T14:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>코틀린의 extension, inline 함수</h3><div class="text-muted small"><p> Extension Function 코틀린 내에 어떤 클래스의 메서드를 정의하는 데에는 두가지 방법이 있다. 하나는 확장함수, 다른 하나는 멤버 변수로써의 함수에 해당한다. 1 2 3 4 5 class Foo { ... } fun Foo.bar() { // Some stuff } 1 2 3 4 5 6 7 8 class Foo { ...</p></div></div></a></div><div class="card"> <a href="/posts/reified/"><div class="card-body"> <span class="timeago small" > Oct 5, 2021 <i class="unloaded">2021-10-05T14:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>코틀린의 reified 키워드</h3><div class="text-muted small"><p> reified키워드는 왜쓸까? 출처 fun &lt;T&gt; genericFunc(c: Class&lt;T&gt;) 와 같이 일반적인 제네릭 함수 body에서 타입 T는 컴파일 타임에는 존재하지만, 런타임 시에는 Type erasure때문에 접근할 수 없게된다. 따라서 일반적인 클래스에 작성된 함수 body에서 제네릭 타입에 접근하고 싶다면 ge...</p></div></div></a></div><div class="card"> <a href="/posts/kotlinStudy1/"><div class="card-body"> <span class="timeago small" > Oct 2, 2021 <i class="unloaded">2021-10-02T11:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>코틀린 var, val 그리고 inline</h3><div class="text-muted small"><p> 인터페이스 상에서의 var과 val의 차이 코틀린에서 ‘var속성과 val속성을 사용한다.’ 라는 것은 결국 ‘속성 처럼’ 보이는 문법을 쓰게 해주는 getter나 setter를 만들어주는 것이다. 또한 이러한 특징은 추상 클래스나 인터페이스에서 추상 수준의 var이나 val을 사용할 수 있게 해준다. 그렇다면 다음과 같은 선언을 보자. 이번 프...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/dockerFilecmd/" class="btn btn-outline-primary" prompt="Older"><p>도커의 Cmd vs EntryPoint</p></a> <a href="/posts/mysql4/" class="btn btn-outline-primary" prompt="Newer"><p>DB의 트랜잭션 (4) 트랜잭션의 격리성, LOCK 세번째</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">vitriol</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://vitriol95.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
