<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="JWT, CSRF, CORS" /><meta property="og:locale" content="ko" /><meta name="description" content="JWT" /><meta property="og:description" content="JWT" /><link rel="canonical" href="https://vitriol95.github.io/posts/jwt/" /><meta property="og:url" content="https://vitriol95.github.io/posts/jwt/" /><meta property="og:site_name" content="Vitriol" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-01T13:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="JWT, CSRF, CORS" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="QsbP4NOwVkaE8CnHpYOl-qNGhxB9m1RbsrBEefA92ao" /> <script type="application/ld+json"> {"headline":"JWT, CSRF, CORS","dateModified":"2021-10-01T13:00:00+09:00","datePublished":"2021-10-01T13:00:00+09:00","description":"JWT","url":"https://vitriol95.github.io/posts/jwt/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://vitriol95.github.io/posts/jwt/"},"@context":"https://schema.org"}</script><title>JWT, CSRF, CORS | Vitriol</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Vitriol"><meta name="application-name" content="Vitriol"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WSY4XYN711"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WSY4XYN711'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Vitriol</a></div><div class="site-subtitle font-italic">기억을 적는 시간</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/vitriol95" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['vitriol951','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>JWT, CSRF, CORS</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>JWT, CSRF, CORS</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> vitriol </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Oct 1, 2021, 1:00 PM +0900" prep="on" > Oct 1, 2021 <i class="unloaded">2021-10-01T13:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2908 words">16 min</span></div></div><div class="post-content"><h2 id="jwt">JWT</h2><p>기존 스프링 시큐리티를 이용했을때는, 세션방식의 로그인 &amp; 인증만을 진행해 봤지만, 이번 프로젝트에서는 JWT토큰을 이용해 프론트 로그인 및 인증을 진행해보려한다.</p><h3 id="왜-쓰는가">왜 쓰는가?</h3><p>HTTP프로토콜을 사용하면서, REST API가 있고 권한이 있는 사용자에게만 엑세스를 준다고 생각해보자.</p><ol><li>가장 단순하게 접근해 보자면 API가 사용자 이름과 비밀번호를 요청하는 것이다. 그리고 이를 DB를 통해 확인을 하고, 권한이 있는지 확인을 할 것이다.<blockquote><p>하지만 HTTP 프로토콜은 stateless하게 동작한다. 즉, 이전 요청에 대해 아무것도 알지 못하기 때문에 새 요청마다 다시 인증을 해야한다.</p></blockquote></ol><blockquote><p>‘StateLess’함이라는 것을 처음에는 잘 이해하지 못했지만 점원과 손님의 대화 예시를 떠올리면 되겠다.</p></blockquote><p><br /></p><ol><li>위의 문제를 해결하기 위해 나온 방법으로는 SSS(server side session)이 존재한다.<ul><li>많이 보았던 Jsession도 이의 일부에 해당한다.<li>사용자의 이름과 비밀번호를 확인하고(로그인) 인증된 경우 서버는 세션ID를 DB에 저장하고 이 ID를 클라이언트에게 반환하게 된다.<li>그 후부터는 클라이언트를 식별하기 위해 세션 ID를 서버로 보내면 된다.<blockquote><p>이정도 까지만 하더라도 클라이언트 UX는 많이 올라가게 된다. (여러번 요청을 보낼일 없다.)</p></blockquote></ul></ol><p><img width="600" src="/assets/img/etc/jwt/1.png" /></p><p><a href="https://smoh.tistory.com/347">이미지 출처</a></p><ol><li>하지만 수평확장과 MSA의 흐름을 타면 또 다른 문제를 낳게된다.<ul><li>클라이언트가 로드밸런서를 태워 서버로 보낸다고 해보자. 서버가 1개인 경우, 해당 레코드들을 모두 메모리에서 찾을 수 있게된다.<li>하지만 수평 확장에 따른 서버가 추가되었다고 했을때, 새로운 서버는 해당 레코드를 찾을 수 없게된다.<blockquote><p>예를 들어 abc라는 세션ID가 구서버에서 인증을 진행했다고 하자. 하지만 새로운 요청을 보냈을때 로드밸런서를 타고 신서버로 들어갔을때는 또 다시 인증을 진행해야한다는 이야기이다.</p></blockquote></ul></ol><p>2-1. 이 상황에서 떠올릴 수 있는 해결책이 존재한다.</p><ul><li>서버간 세션의 동기화: 생각을 오래하지 않아도 비효율적이며 까다롭다.<li>외부의 DB사용(Reddis): 좋은 대안이 될 수 있지만, 관리해야할 구성 요소가 추가된다.<li>HTTP의 stateless 특성을 수용한 토큰방식의 인증</ul><ol><li>토큰방식의 인증 - JWT에 대해<ul><li>당사자간의 정보를 JSON객체로 안전하게 전송하기 위해 만들어진 방식에 해당한다. (비)대칭 키를 이용해 디지털 서명이 되어있어 안전함을 더한다.<li>토큰을 사용하면 세션방식과 달리 서버측의 부하를 낮출 수 있고(저장공간 down), 앞서 이야기한 수평확장 구조에 좀 더 유연하게 대응이 가능하다.</ul><li>JWT 구조<ul><li>Header, Payload(body), Signature로 이루어져 있다. ( header.payload.signature 형식)</ul></ol><p><img width="600" src="/assets/img/etc/jwt/2.png" /></p><p><a href="https://jwt.io">출처</a></p><ul><li>빨간 부분이 헤더에 대한 설명이며 암호화를 하는데 쓰인 알고리즘에 대한 정보가 나와있다. 토큰 자체에 대한 메타데이터라고 보면 될거같다.<li>보라색 부분은 토큰의 핵심에 해당하는데, 이 안에 subject에 대한 각종 정보(클레임)들이 포함되어 있다.<li>마지막으로 파란색 부분은 계산된 해시에 해당하는데, 인코딩된 헤더와 페이로드를 합치고 헤더에 나온 알고리즘 + 개인키에 지정된 알고리즘을 사용해 결과값을 해시한다. 이후 이를 Base64URL로 인코딩하게 된다. (알고리즘별로 secretkey에 해당하는 형식과 길이가 다르다!)</ul><ol><li>좋은것은 알겠지만 단점은?</ol><ul><li>가장 먼저 떠올릴 수 있는 단점은 다음과 같았다.<blockquote><p>payload에 들어가는 필드수가 많아지면 토큰이 비대해질 수 있고, 모든 요청들에 대해 토큰이 전송되면 트래픽에 영향을 줄 수 있다.</p></blockquote></ul><blockquote><p>마지막 암호화에 들어가는 secret-key를 잘 관리해야할 듯 하다.</p><ul><li>그리고, 로그아웃에 대해 문제도 있지 않을까 생각한다.<li>기존 세션 방식의 경우에는 세션 스토리지에서 해당 세션 값을 날리면 된다. 하지만 이 Stateless한 토큰은 어떻게 처리할 것인가. 이를 해결하기 위해 주기가 짧은 access_token과 주기가 긴 refresh_token을 나누어 배부하는 방법이 있다. 그리고 시스템에서 만료된 토큰을 저장해 가리는 방법도 존재한다.<li>하지만 이 두가지 방법 모두 결국 관리가 필요하다는 것인데.. 이러면 장점을 어느정도 상쇄하지 않을까라고 생각한다(어찌보면 세션으로 관리하는 것이 편할것 같은데..)</ul></blockquote><h2 id="csrf-token--cors">CSRF token &amp; CORS</h2><p>이 두가지를 많이 보고, 공부했었지만 볼때마다 헷갈리는 것은 사실이다. (인증, 보안 관련부분들은 항상 이런듯 하다..)</p><h3 id="csrfcross-site-request-forgery-token">CSRF(Cross Site request Forgery) token</h3><ol><li>CSRF공격을 막기 위해 고안된 토큰에 해당한다. 서버에서는 뷰 페이지를 발행할 때 랜덤으로 생성된 토큰을 같이 준 뒤 사용자 세션에 저장을 해둔다.<blockquote><p>이후 사용자가 서버에 요청을 보내면, 페이지에 hidden으로 숨어있는 토큰 값을 같이 서버에 전송하게 되며 서버는 이 값이 일치하는 지 확인하여 위조 여부를 판단한다.</p></blockquote></ol><blockquote><p>이 csrf토큰은 모두 1회용이기에, 유출되더라도 악용의 가능성이 거의 없다.</p></blockquote><h4 id="스프링-시큐리티를-사용하면">스프링 시큐리티를 사용하면</h4><p>시큐리티 3.2.0 이후 버전부터 기본값으로 적용이 된다. 모든 POST 방식의 데이터 전송에 토큰 값이 있어야 하고, 이 값이 존재하지 않는다면 에러를 뱉게된다.</p><blockquote><p>만약 GET방식도 막아두게 되면 다른 사이트에서 링크를 타고 들어오는 요청이나 Restful API를 처리할 수 없게된다.</p></blockquote><ul><li>만약 타임리프와 같은 시큐리티 통합기능을 지원하는 SSR을 사용하면 form에 자동으로이 값이 함께 전송된다. (완전 편했다.)<li>하지만, ajax등으로 보내야 할 경우에는 직접 csrf를 헤더에 붙혀서 보내주어야 한다. (하지만 이것도 어렵지 않게 접근가능하다)<li>스프링 시큐리티가 Default Logout(/logout)의 메서드를 POST로 해둔 이유도 이의 일부에 해당한다.</ul><h3 id="corscross-origin-resource-sharing">CORS(Cross Origin Resource Sharing)</h3><p>이전까지는 뷰와 같은 독립적인 프론트엔드단을 두지 않고 프로젝트를 진행했었기에, 이에 대해 크게 신경쓰지 않았지만 통신에 있어 굉장히 중요한 부분이다.</p><blockquote><p>프로토콜, 서브도메인, 도메인, 포트중 하나만 달라도 CORS에러가 나게된다.</p></blockquote><ol><li>브라우저 기본값<ul><li>보안상의 이유로, 브라우저는 cross-origin Http 요청에 대해서 same-origin policy를 적용하여 동작한다.<blockquote><p>즉, a.com이라는 도메인의 클라이언트에서 리소스를 요청할 때에는 a.com이라는 도메인 서버일 경우에만 CORS문제가 발생하지 않고 정상적으로 동작하게 된다.</p></blockquote></ul></ol><blockquote><p>만약 두 도메인이 서로 다른 값이라면, CORS에 대해 header 설정을 해 주어야 정상적으로 요청 &amp; 응답이 이루어진다.</p></blockquote><ol><li>두가지 리퀘스트<ul><li>2.1 Simple Request</ul><ul><li>클라이언트와 서버간에 한번만 요청 및 응답을 주고받게 된다. (Get, head, post만 가능하다)<li>커스텀 헤더를 전송할 수 없고, 허용되는 헤더들이 존재한다.<li>Content-type으로 허용되는 값들이 정해져있다.(json/text/multipart-form) - 2.2 Preflight Request<li>Simple Request 조건에 만족하지 않으면 이 방식으로 요청이 된다. Option 메서드를 이용해 서버로 부터 안전한 요청인지 응답을 받고 본 요청을 수행하게 된다.<li>CORS요청시에는 미리 OPTIONS주소로 서버가 CORS를 허용하는지 물어보고 미리 메서드와 헤더를 알려주게 된다.</ul><li>스프링 시큐리티를 이용한다면<ul><li>만약 cors에 대한 제어를 놓고싶다면 http를 configure하는 메서드에서 <code class="language-plaintext highlighter-rouge">cors().disable()</code>을 진행하면 된다.<li>하지만, 위 방법보다는 프론트엔드의 주소만을 허용해주는 것이 가장 좋을듯하다.</ul><li>관련 헤더<ul><li>요청시</ul><ul><li>Origin : 어디서 그 요청이 왔는지에 해당한다. 나는 8000번 포트에서 뷰를 돌리고 있으니, Origin:http://localhost:8000으로 찍힐것이다.<li>Access-Control-Request-Method : Preflight요청을 날려서 실제 보내고자하는 메서드를 알리게된다.<li>Access-Control-Request-Headers : Preflight요청을 날리며, 실제 사용될 헤더들을 보내게 된다.<li>위 세가지는 모두 Preflight request에 들어간다.<blockquote><p>응답이 오면 브라우저는 위의 3가지 헤더값과 응답의 헤더를 비교하며 실제 요청을 서버에게 보낼 지 결정한다.</p></blockquote></ul></ol><ul><li>응답시(ALLOW는 요청시의 REQUEST에 대응한다고 생각)<ul><li>Access-Control-Allow-Origin : 요청을 허용하는 origin들을 나타내주게 된다. 만약 모두 허용한다면 *이 표시된다.<li>Access-Control-Allow-Credentials : T/F 값으로 ‘쿠키와 같은 값을 요청에 넣을 수 있는지’를 알려준다.<li>Access-Control-Expose-Headers : 브라우저가 스크립트에 노출 시킬 헤더의 목록을 명시한다<li>Access-Control-Max-Age : preflight 요청에 대한 응답을 브라우저에서 얼마동안 캐싱하고 있을지 설정할 때 사용한다.<li>Access-Control-Allow-Methods : 어떤 메서드들을 허용할 것인지 명시한다.<li>Access-Control-Allow-Headers : 어떤 헤더들을 허용할 것인지 명시한다.</ul></ul><h3 id="주의점">주의점</h3><h4 id="access-control-allow-origin-와-access-control-allow-credentials-true는-함께-사용할-수-없다">Access-Control-Allow-Origin: *와 Access-Control-Allow-Credentials: true는 함께 사용할 수 없다.</h4><p>Access-Control-Allow-Credentials: true를 사용하는 경우는 사용자 인증이 필요한 리소스 접근이 필요한 경우에 해당한다. 이때 모든 origin을 허용하게 된다면 CSRF 공격에 매우 취약해 지게 되어 악의적인 사용자가 인증이 필요한 리소스를 마음대로 접근할 수 있게된다.</p><blockquote><p>따라서 이를 아예 동작하지 않도록 막아둔 것이다.</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/jwt/" class="post-tag no-text-decoration" >jwt</a> <a href="/tags/security/" class="post-tag no-text-decoration" >security</a> <a href="/tags/csrf/" class="post-tag no-text-decoration" >csrf</a> <a href="/tags/cors/" class="post-tag no-text-decoration" >cors</a> <a href="/tags/session/" class="post-tag no-text-decoration" >session</a> <a href="/tags/token/" class="post-tag no-text-decoration" >token</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=JWT, CSRF, CORS - Vitriol&url=https://vitriol95.github.io/posts/jwt/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=JWT, CSRF, CORS - Vitriol&u=https://vitriol95.github.io/posts/jwt/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=JWT, CSRF, CORS - Vitriol&url=https://vitriol95.github.io/posts/jwt/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/batchbase1/">스프링 배치 - 1 스프링 배치란?</a><li><a href="/posts/batchbase2/">스프링 배치 - 2 DB 스키마에 대한 이해</a><li><a href="/posts/batchbase3/">스프링 배치 - 3 도메인 뜯어보기(JOB)</a><li><a href="/posts/batchbase4/">스프링 배치 - 4 도메인 뜯어보기(STEP)</a><li><a href="/posts/batchbase5/">스프링 배치 - 5 청크 지향 처리</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/batchbase10/"><div class="card-body"> <span class="timeago small" > Nov 7, 2021 <i class="unloaded">2021-11-07T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>스프링 배치 - 10 faultTolerant</h3><div class="text-muted small"><p> FaultTolerant 큰 의미로 이번 기능또한 마찬가지로 배치 반복 및 오류제어 카테고리에 들어간다. 해당 옵션또한 여러 청크지향 프로세스에 자주등장하며, 장애 처리에 대해 복원력을 향상시킬 수 있는 방법이다. 단어 그대로, fault에 대해 tolerant하게 버틴다는것이다. 즉, 해당 기능을 이용하면 오류가 발생해도 Step이 즉...</p></div></div></a></div><div class="card"> <a href="/posts/batchbase9/"><div class="card-body"> <span class="timeago small" > Nov 7, 2021 <i class="unloaded">2021-11-07T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>스프링 배치 - 9 배치 반복 및 오류제어 두번째</h3><div class="text-muted small"><p> 첫번째에선 배치 반복 및 오류제어 글을 쓰다보니 너무 길어져 한번 짜르고 이어가도록 하겠다. 앞선 포스트에서는 배치 반복 및 오류제어와 관련된 이야기를 이해하기 위해 큰 흐름을 뒤짚어 보았을 뿐이다. 요약하자면 청크기반이 아닌 스텝은 RepeatOperation인 stepOperation을 가지고있고, 청크기반인 스텝은 RepeatOperati...</p></div></div></a></div><div class="card"> <a href="/posts/batchbase8/"><div class="card-body"> <span class="timeago small" > Nov 7, 2021 <i class="unloaded">2021-11-07T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>스프링 배치 - 8 배치 반복 및 오류제어 첫번째</h3><div class="text-muted small"><p> Repeat 스프링 배치는 얼마나 작업을 반복해야 하는지 알려줄 수 있는 기능을 제공한다. 특정 조건이 충족되거나, 아닐경우에 Job, Step을 반복하도록 구성할 수 있다는 것이다. Step과 Chunk의 반복을 RepeatOperation을 통해서 처리하고 있기에 가능한 것이다. 이의 기본 구현체는 RepeatTemplate에 해당한다...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gitflow/" class="btn btn-outline-primary" prompt="Older"><p>Git Flow</p></a> <a href="/posts/mysql1/" class="btn btn-outline-primary" prompt="Newer"><p>DB의 트랜잭션 (1) 트랜잭션의 성질</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">vitriol</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/python3/">python3</a> <a class="post-tag" href="/tags/boj/">boj</a> <a class="post-tag" href="/tags/problem/">problem</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/springboot/">springboot</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring-mvc/">spring mvc</a> <a class="post-tag" href="/tags/springframework/">springframework</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://vitriol95.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
